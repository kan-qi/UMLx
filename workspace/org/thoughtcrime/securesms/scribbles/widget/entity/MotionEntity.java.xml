<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="0.9.5" language="Java" filename="D:\AndroidAnalysis\Instrumentation-apps\Signal-Android\src\org\thoughtcrime\securesms\scribbles\widget\entity\MotionEntity.java"><comment type="block" format="javadoc">/**
 * Copyright (c) 2016 UPTech
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>
<package>package <name><name>org</name><operator>.</operator><name>thoughtcrime</name><operator>.</operator><name>securesms</name><operator>.</operator><name>scribbles</name><operator>.</operator><name>widget</name><operator>.</operator><name>entity</name></name>;</package>

<import>import <name><name>android</name><operator>.</operator><name>graphics</name><operator>.</operator><name>Canvas</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>graphics</name><operator>.</operator><name>Matrix</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>graphics</name><operator>.</operator><name>Paint</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>graphics</name><operator>.</operator><name>PointF</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>support</name><operator>.</operator><name>annotation</name><operator>.</operator><name>IntRange</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>support</name><operator>.</operator><name>annotation</name><operator>.</operator><name>NonNull</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>support</name><operator>.</operator><name>annotation</name><operator>.</operator><name>Nullable</name></name>;</import>

<import>import <name><name>org</name><operator>.</operator><name>thoughtcrime</name><operator>.</operator><name>securesms</name><operator>.</operator><name>util</name><operator>.</operator><name>MathUtils</name></name>;</import>
<import>import <name><name>org</name><operator>.</operator><name>thoughtcrime</name><operator>.</operator><name>securesms</name><operator>.</operator><name>scribbles</name><operator>.</operator><name>viewmodel</name><operator>.</operator><name>Layer</name></name>;</import>


<class><annotation>@<name>SuppressWarnings</name><argument_list>(<argument><expr><block>{<expr><literal type="string">"WeakerAccess"</literal></expr>}</block></expr></argument>)</argument_list></annotation>
<specifier>public</specifier> <specifier>abstract</specifier> class <name>MotionEntity</name> <block>{

  <comment type="block" format="javadoc">/**
   * data
   */</comment>
  <decl_stmt><decl><annotation>@<name>NonNull</name></annotation>
  <specifier>protected</specifier> <type><specifier>final</specifier> <name>Layer</name></type> <name>layer</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * transformation matrix for the entity
   */</comment>
  <decl_stmt><decl><specifier>protected</specifier> <type><specifier>final</specifier> <name>Matrix</name></type> <name>matrix</name> <init>= <expr><operator>new</operator> <call><name>Matrix</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/**
   * true - entity is selected and need to draw it's border
   * false - not selected, no need to draw it's border
   */</comment>
  <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>isSelected</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * maximum scale of the initial image, so that
   * the entity still fits within the parent canvas
   */</comment>
  <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>holyScale</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * width of canvas the entity is drawn in
   */</comment>
  <decl_stmt><decl><annotation>@<name>IntRange</name><argument_list>(<argument><expr><name>from</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></annotation>
  <specifier>protected</specifier> <type><name>int</name></type> <name>canvasWidth</name></decl>;</decl_stmt>
  <comment type="block" format="javadoc">/**
   * height of canvas the entity is drawn in
   */</comment>
  <decl_stmt><decl><annotation>@<name>IntRange</name><argument_list>(<argument><expr><name>from</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></annotation>
  <specifier>protected</specifier> <type><name>int</name></type> <name>canvasHeight</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Destination points of the entity
   * 5 points. Size of array - 10; Starting upper left corner, clockwise
   * last point is the same as first to close the circle
   * NOTE: saved as a field variable in order to avoid creating array in draw()-like methods
   */</comment>
  <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>destPoints</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// x0, y0, x1, y1, x2, y2, x3, y3, x0, y0</comment>
  <comment type="block" format="javadoc">/**
   * Initial points of the entity
   * @see #destPoints
   */</comment>
  <decl_stmt><decl><specifier>protected</specifier> <type><specifier>final</specifier> <name><name>float</name><index>[]</index></name></type> <name>srcPoints</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="line">// x0, y0, x1, y1, x2, y2, x3, y3, x0, y0</comment>

  <decl_stmt><decl><annotation>@<name>NonNull</name></annotation>
  <specifier>private</specifier> <type><name>Paint</name></type> <name>borderPaint</name> <init>= <expr><operator>new</operator> <call><name>Paint</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <constructor><specifier>public</specifier> <name>MotionEntity</name><parameter_list>(<parameter><decl><type><annotation>@<name>NonNull</name></annotation> <name>Layer</name></type> <name>layer</name></decl></parameter>,
                      <parameter><decl><type><annotation>@<name>IntRange</name><argument_list>(<argument><expr><name>from</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></annotation> <name>int</name></type> <name>canvasWidth</name></decl></parameter>,
                      <parameter><decl><type><annotation>@<name>IntRange</name><argument_list>(<argument><expr><name>from</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></annotation> <name>int</name></type> <name>canvasHeight</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>layer</name></name> <operator>=</operator> <name>layer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>canvasWidth</name></name> <operator>=</operator> <name>canvasWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>canvasHeight</name></name> <operator>=</operator> <name>canvasHeight</name></expr>;</expr_stmt>
  }</block></constructor>

  <function><specifier>private</specifier> <type><name>boolean</name></type> <name>isSelected</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><name>isSelected</name></expr>;</return>
  }</block></function>

  <function><specifier>public</specifier> <type><name>void</name></type> <name>setIsSelected</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>isSelected</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>isSelected</name></name> <operator>=</operator> <name>isSelected</name></expr>;</expr_stmt>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * S - scale matrix, R - rotate matrix, T - translate matrix,
   * L - result transformation matrix
   * &lt;p&gt;
   * The correct order of applying transformations is : L = S * R * T
   * &lt;p&gt;
   * See more info: &lt;a href="http://gamedev.stackexchange.com/questions/29260/transform-matrix-multiplication-order"&gt;Game Dev: Transform Matrix multiplication order&lt;/a&gt;
   * &lt;p&gt;
   * Preconcat works like M` = M * S, so we apply preScale -&gt; preRotate -&gt; preTranslate
   * the result will be the same: L = S * R * T
   * &lt;p&gt;
   * NOTE: postconcat (postScale, etc.) works the other way : M` = S * M, in order to use it
   * we'd need to reverse the order of applying
   * transformations : post holy scale -&gt;  postTranslate -&gt; postRotate -&gt; postScale
   */</comment>
  <function><specifier>protected</specifier> <type><name>void</name></type> <name>updateMatrix</name><parameter_list>()</parameter_list> <block>{
    <comment type="line">// init matrix to E - identity matrix</comment>
    <expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>float</name></type> <name>widthAspect</name> <init>= <expr><literal type="number">1.0F</literal> <operator>*</operator> <name>canvasWidth</name> <operator>/</operator> <call><name>getWidth</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>heightAspect</name> <init>= <expr><literal type="number">1.0F</literal> <operator>*</operator> <name>canvasHeight</name> <operator>/</operator> <call><name>getHeight</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// fit the smallest size</comment>
    <expr_stmt><expr><name>holyScale</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>widthAspect</name></expr></argument>, <argument><expr><name>heightAspect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>float</name></type> <name>topLeftX</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getX</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>canvasWidth</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>topLeftY</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getY</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>canvasHeight</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>float</name></type> <name>centerX</name> <init>= <expr><name>topLeftX</name> <operator>+</operator> <call><name>getWidth</name><argument_list>()</argument_list></call> <operator>*</operator> <name>holyScale</name> <operator>*</operator> <literal type="number">0.5F</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>centerY</name> <init>= <expr><name>topLeftY</name> <operator>+</operator> <call><name>getHeight</name><argument_list>()</argument_list></call> <operator>*</operator> <name>holyScale</name> <operator>*</operator> <literal type="number">0.5F</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// calculate params</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>rotationInDegree</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getRotationInDegrees</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>scaleX</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>scaleY</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getScale</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>layer</name><operator>.</operator><name>isFlipped</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// flip (by X-coordinate) if needed</comment>
      <expr_stmt><expr><name>rotationInDegree</name> <operator>*=</operator> <operator>-</operator><literal type="number">1.0F</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>scaleX</name> <operator>*=</operator> <operator>-</operator><literal type="number">1.0F</literal></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// applying transformations : L = S * R * T</comment>

    <comment type="line">// scale</comment>
    <expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>preScale</name></name><argument_list>(<argument><expr><name>scaleX</name></expr></argument>, <argument><expr><name>scaleY</name></expr></argument>, <argument><expr><name>centerX</name></expr></argument>, <argument><expr><name>centerY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// rotate</comment>
    <expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>preRotate</name></name><argument_list>(<argument><expr><name>rotationInDegree</name></expr></argument>, <argument><expr><name>centerX</name></expr></argument>, <argument><expr><name>centerY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// translate</comment>
    <expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>preTranslate</name></name><argument_list>(<argument><expr><name>topLeftX</name></expr></argument>, <argument><expr><name>topLeftY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// applying holy scale - S`, the result will be : L = S * R * T * S`</comment>
    <expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>preScale</name></name><argument_list>(<argument><expr><name>holyScale</name></expr></argument>, <argument><expr><name>holyScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><specifier>public</specifier> <type><name>float</name></type> <name>absoluteCenterX</name><parameter_list>()</parameter_list> <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>topLeftX</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getX</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>canvasWidth</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>topLeftX</name> <operator>+</operator> <call><name>getWidth</name><argument_list>()</argument_list></call> <operator>*</operator> <name>holyScale</name> <operator>*</operator> <literal type="number">0.5F</literal></expr>;</return>
  }</block></function>

  <function><specifier>public</specifier> <type><name>float</name></type> <name>absoluteCenterY</name><parameter_list>()</parameter_list> <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>topLeftY</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getY</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>canvasHeight</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><name>topLeftY</name> <operator>+</operator> <call><name>getHeight</name><argument_list>()</argument_list></call> <operator>*</operator> <name>holyScale</name> <operator>*</operator> <literal type="number">0.5F</literal></expr>;</return>
  }</block></function>

  <function><specifier>public</specifier> <type><name>PointF</name></type> <name>absoluteCenter</name><parameter_list>()</parameter_list> <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>topLeftX</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getX</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>canvasWidth</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>topLeftY</name> <init>= <expr><call><name><name>layer</name><operator>.</operator><name>getY</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>canvasHeight</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>float</name></type> <name>centerX</name> <init>= <expr><name>topLeftX</name> <operator>+</operator> <call><name>getWidth</name><argument_list>()</argument_list></call> <operator>*</operator> <name>holyScale</name> <operator>*</operator> <literal type="number">0.5F</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>centerY</name> <init>= <expr><name>topLeftY</name> <operator>+</operator> <call><name>getHeight</name><argument_list>()</argument_list></call> <operator>*</operator> <name>holyScale</name> <operator>*</operator> <literal type="number">0.5F</literal></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>new</operator> <call><name>PointF</name><argument_list>(<argument><expr><name>centerX</name></expr></argument>, <argument><expr><name>centerY</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function><specifier>public</specifier> <type><name>void</name></type> <name>moveToCanvasCenter</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name>moveCenterTo</name><argument_list>(<argument><expr><operator>new</operator> <call><name>PointF</name><argument_list>(<argument><expr><name>canvasWidth</name> <operator>*</operator> <literal type="number">0.5F</literal></expr></argument>, <argument><expr><name>canvasHeight</name> <operator>*</operator> <literal type="number">0.5F</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><specifier>public</specifier> <type><name>void</name></type> <name>moveCenterTo</name><parameter_list>(<parameter><decl><type><name>PointF</name></type> <name>moveToCenter</name></decl></parameter>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>PointF</name></type> <name>currentCenter</name> <init>= <expr><call><name>absoluteCenter</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>layer</name><operator>.</operator><name>postTranslate</name></name><argument_list>(<argument><expr><literal type="number">1.0F</literal> <operator>*</operator> <operator>(</operator><name><name>moveToCenter</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>currentCenter</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <name>canvasWidth</name></expr></argument>,
                        <argument><expr><literal type="number">1.0F</literal> <operator>*</operator> <operator>(</operator><name><name>moveToCenter</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>currentCenter</name><operator>.</operator><name>y</name></name><operator>)</operator> <operator>/</operator> <name>canvasHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>PointF</name></type> <name>pA</name> <init>= <expr><operator>new</operator> <call><name>PointF</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>PointF</name></type> <name>pB</name> <init>= <expr><operator>new</operator> <call><name>PointF</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>PointF</name></type> <name>pC</name> <init>= <expr><operator>new</operator> <call><name>PointF</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>PointF</name></type> <name>pD</name> <init>= <expr><operator>new</operator> <call><name>PointF</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * For more info:
   * &lt;a href="http://math.stackexchange.com/questions/190111/how-to-check-if-a-point-is-inside-a-rectangle"&gt;StackOverflow: How to check point is in rectangle&lt;/a&gt;
   * &lt;p&gt;NOTE: it's easier to apply the same transformation matrix (calculated before) to the original source points, rather than
   * calculate the result points ourselves
   * @param point point
   * @return true if point (x, y) is inside the triangle
   */</comment>
  <function><specifier>public</specifier> <type><name>boolean</name></type> <name>pointInLayerRect</name><parameter_list>(<parameter><decl><type><name>PointF</name></type> <name>point</name></decl></parameter>)</parameter_list> <block>{

    <expr_stmt><expr><call><name>updateMatrix</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// map rect vertices</comment>
    <expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>mapPoints</name></name><argument_list>(<argument><expr><name>destPoints</name></expr></argument>, <argument><expr><name>srcPoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pA</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pA</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pB</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pB</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pC</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pD</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pD</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>destPoints</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>;</expr_stmt>

    <return>return <expr><call><name><name>MathUtils</name><operator>.</operator><name>pointInTriangle</name></name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>MathUtils</name><operator>.</operator><name>pointInTriangle</name></name><argument_list>(<argument><expr><name>point</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pD</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * http://judepereira.com/blog/calculate-the-real-scale-factor-and-the-angle-of-rotation-from-an-android-matrix/
   *
   * @param canvas Canvas to draw
   * @param drawingPaint Paint to use during drawing
   */</comment>
  <function><specifier>public</specifier> <specifier>final</specifier> <type><name>void</name></type> <name>draw</name><parameter_list>(<parameter><decl><type><annotation>@<name>NonNull</name></annotation> <name>Canvas</name></type> <name>canvas</name></decl></parameter>, <parameter><decl><type><annotation>@<name>Nullable</name></annotation> <name>Paint</name></type> <name>drawingPaint</name></decl></parameter>)</parameter_list> <block>{

    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>canvasWidth</name></name> <operator>=</operator> <call><name><name>canvas</name><operator>.</operator><name>getWidth</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>canvasHeight</name></name> <operator>=</operator> <call><name><name>canvas</name><operator>.</operator><name>getHeight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>updateMatrix</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>canvas</name><operator>.</operator><name>save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>drawContent</name><argument_list>(<argument><expr><name>canvas</name></expr></argument>, <argument><expr><name>drawingPaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>isSelected</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// get alpha from drawingPaint</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>storedAlpha</name> <init>= <expr><call><name><name>borderPaint</name><operator>.</operator><name>getAlpha</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>drawingPaint</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>borderPaint</name><operator>.</operator><name>setAlpha</name></name><argument_list>(<argument><expr><call><name><name>drawingPaint</name><operator>.</operator><name>getAlpha</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>drawSelectedBg</name><argument_list>(<argument><expr><name>canvas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// restore border alpha</comment>
      <expr_stmt><expr><call><name><name>borderPaint</name><operator>.</operator><name>setAlpha</name></name><argument_list>(<argument><expr><name>storedAlpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>canvas</name><operator>.</operator><name>restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><specifier>private</specifier> <type><name>void</name></type> <name>drawSelectedBg</name><parameter_list>(<parameter><decl><type><name>Canvas</name></type> <name>canvas</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>mapPoints</name></name><argument_list>(<argument><expr><name>destPoints</name></expr></argument>, <argument><expr><name>srcPoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//noinspection Range</comment>
    <expr_stmt><expr><call><name><name>canvas</name><operator>.</operator><name>drawLines</name></name><argument_list>(<argument><expr><name>destPoints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>borderPaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//noinspection Range</comment>
    <expr_stmt><expr><call><name><name>canvas</name><operator>.</operator><name>drawLines</name></name><argument_list>(<argument><expr><name>destPoints</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>borderPaint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><annotation>@<name>NonNull</name></annotation>
  <specifier>public</specifier> <type><name>Layer</name></type> <name>getLayer</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><name>layer</name></expr>;</return>
  }</block></function>

  <function><specifier>public</specifier> <type><name>void</name></type> <name>setBorderPaint</name><parameter_list>(<parameter><decl><type><annotation>@<name>NonNull</name></annotation> <name>Paint</name></type> <name>borderPaint</name></decl></parameter>)</parameter_list> <block>{
    <expr_stmt><expr><name><name>this</name><operator>.</operator><name>borderPaint</name></name> <operator>=</operator> <name>borderPaint</name></expr>;</expr_stmt>
  }</block></function>

  <function_decl><specifier>protected</specifier> <specifier>abstract</specifier> <type><name>void</name></type> <name>drawContent</name><parameter_list>(<parameter><decl><type><annotation>@<name>NonNull</name></annotation> <name>Canvas</name></type> <name>canvas</name></decl></parameter>, <parameter><decl><type><annotation>@<name>Nullable</name></annotation> <name>Paint</name></type> <name>drawingPaint</name></decl></parameter>)</parameter_list>;</function_decl>

  <function_decl><specifier>public</specifier> <specifier>abstract</specifier> <type><name>int</name></type> <name>getWidth</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><specifier>public</specifier> <specifier>abstract</specifier> <type><name>int</name></type> <name>getHeight</name><parameter_list>()</parameter_list>;</function_decl>

  <function><specifier>public</specifier> <type><name>void</name></type> <name>release</name><parameter_list>()</parameter_list> <block>{
    <comment type="line">// free resources here</comment>
  }</block></function>

  <function><specifier>public</specifier> <type><name>void</name></type> <name>updateEntity</name><parameter_list>()</parameter_list> <block>{}</block></function>

  <function><annotation>@<name>Override</name></annotation>
  <specifier>protected</specifier> <type><name>void</name></type> <name>finalize</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Throwable</name></expr></argument></throws> <block>{
    <try>try <block>{
      <expr_stmt><expr><call><name>release</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block> <finally>finally <block>{
      <comment type="line">//noinspection ThrowFromFinallyBlock</comment>
      <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>finalize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></finally></try>
  }</block></function>
}</block></class></unit>
