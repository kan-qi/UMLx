<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="0.9.5" language="Java" filename="D:\AndroidAnalysis\Instrumentation-apps\superCleanMaster\app\src\main\java\com\balaganovrocks\yourmasterclean\swipeback\ViewDragHelper.java"><comment type="block">/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>com</name><operator>.</operator><name>balaganovrocks</name><operator>.</operator><name>yourmasterclean</name><operator>.</operator><name>swipeback</name></name>;</package>

<import>import <name><name>android</name><operator>.</operator><name>content</name><operator>.</operator><name>Context</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>support</name><operator>.</operator><name>v4</name><operator>.</operator><name>view</name><operator>.</operator><name>MotionEventCompat</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>support</name><operator>.</operator><name>v4</name><operator>.</operator><name>view</name><operator>.</operator><name>VelocityTrackerCompat</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>support</name><operator>.</operator><name>v4</name><operator>.</operator><name>view</name><operator>.</operator><name>ViewCompat</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>support</name><operator>.</operator><name>v4</name><operator>.</operator><name>widget</name><operator>.</operator><name>ScrollerCompat</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>view</name><operator>.</operator><name>MotionEvent</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>view</name><operator>.</operator><name>VelocityTracker</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>view</name><operator>.</operator><name>View</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>view</name><operator>.</operator><name>ViewConfiguration</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>view</name><operator>.</operator><name>ViewGroup</name></name>;</import>
<import>import <name><name>android</name><operator>.</operator><name>view</name><operator>.</operator><name>animation</name><operator>.</operator><name>Interpolator</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Arrays</name></name>;</import>

<comment type="block" format="javadoc">/**
 * ViewDragHelper is a utility class for writing custom ViewGroups. It offers a
 * number of useful operations and state tracking for allowing a user to drag
 * and reposition views within their parent ViewGroup.
 */</comment>
<class><specifier>public</specifier> class <name>ViewDragHelper</name> <block>{
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>String</name></type> <name>TAG</name> <init>= <expr><literal type="string">"ViewDragHelper"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A null/invalid pointer ID.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>INVALID_POINTER</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A view is not currently being dragged or animating as a result of a
     * fling/snap.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>STATE_IDLE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A view is currently being dragged. The position is currently changing as
     * a result of user input or simulated user input.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>STATE_DRAGGING</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A view is currently settling into place as a result of a fling or
     * predefined non-interactive motion.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>STATE_SETTLING</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Edge flag indicating that the left edge should be affected.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>EDGE_LEFT</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Edge flag indicating that the right edge should be affected.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>EDGE_RIGHT</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Edge flag indicating that the top edge should be affected.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>EDGE_TOP</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Edge flag indicating that the bottom edge should be affected.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>EDGE_BOTTOM</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Edge flag set indicating all edges should be affected.
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>EDGE_ALL</name> <init>= <expr><name>EDGE_LEFT</name> <operator>|</operator> <name>EDGE_TOP</name> <operator>|</operator> <name>EDGE_RIGHT</name> <operator>|</operator> <name>EDGE_BOTTOM</name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Indicates that a check should occur along the horizontal axis
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>DIRECTION_HORIZONTAL</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Indicates that a check should occur along the vertical axis
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>DIRECTION_VERTICAL</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Indicates that a check should occur along all axes
     */</comment>
    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>DIRECTION_ALL</name> <init>= <expr><name>DIRECTION_HORIZONTAL</name> <operator>|</operator> <name>DIRECTION_VERTICAL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>public</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>EDGE_SIZE</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt> <comment type="line">// dp</comment>

    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>BASE_SETTLE_DURATION</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt> <comment type="line">// ms</comment>

    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>int</name></type> <name>MAX_SETTLE_DURATION</name> <init>= <expr><literal type="number">600</literal></expr></init></decl>;</decl_stmt> <comment type="line">// ms</comment>

    <comment type="line">// Current drag state; idle, dragging or settling</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>mDragState</name></decl>;</decl_stmt>

    <comment type="line">// Distance to travel before a drag may begin</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>mTouchSlop</name></decl>;</decl_stmt>

    <comment type="line">// Last known position/pointer tracking</comment>
    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>mActivePointerId</name> <init>= <expr><name>INVALID_POINTER</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>mInitialMotionX</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>mInitialMotionY</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>mLastMotionX</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>mLastMotionY</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>mInitialEdgeTouched</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>mEdgeDragsInProgress</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>mEdgeDragsLocked</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>mPointersDown</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>VelocityTracker</name></type> <name>mVelocityTracker</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>float</name></type> <name>mMaxVelocity</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>float</name></type> <name>mMinVelocity</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>mEdgeSize</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>mTrackingEdges</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>ScrollerCompat</name></type> <name>mScroller</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>Callback</name></type> <name>mCallback</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>View</name></type> <name>mCapturedView</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><name>boolean</name></type> <name>mReleaseInProgress</name></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>ViewGroup</name></type> <name>mParentView</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * A Callback is used as a communication channel with the ViewDragHelper
     * back to the parent view using it. &lt;code&gt;on*&lt;/code&gt;methods are invoked on
     * siginficant events and several accessor methods are expected to provide
     * the ViewDragHelper with more information about the state of the parent
     * view upon request. The callback also makes decisions governing the range
     * and draggability of child views.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>abstract</specifier> class <name>Callback</name> <block>{
        <comment type="block" format="javadoc">/**
         * Called when the drag state changes. See the &lt;code&gt;STATE_*&lt;/code&gt;
         * constants for more information.
         *
         * @param state The new drag state
         * @see #STATE_IDLE
         * @see #STATE_DRAGGING
         * @see #STATE_SETTLING
         */</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>onViewDragStateChanged</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called when the captured view's position changes as the result of a
         * drag or settle.
         *
         * @param changedView View whose position changed
         * @param left        New X coordinate of the left edge of the view
         * @param top         New Y coordinate of the top edge of the view
         * @param dx          Change in X position from the last call
         * @param dy          Change in Y position from the last call
         */</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>onViewPositionChanged</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>changedView</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dy</name></decl></parameter>)</parameter_list> <block>{
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called when a child view is captured for dragging or settling. The ID
         * of the pointer currently dragging the captured view is supplied. If
         * activePointerId is identified as {@link #INVALID_POINTER} the capture
         * is programmatic instead of pointer-initiated.
         *
         * @param capturedChild   Child view that was captured
         * @param activePointerId Pointer id tracking the child capture
         */</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>onViewCaptured</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>capturedChild</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>activePointerId</name></decl></parameter>)</parameter_list> <block>{
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called when the child view is no longer being actively dragged. The
         * fling velocity is also supplied, if relevant. The velocity values may
         * be clamped to system minimums or maximums.
         * &lt;p&gt;
         * Calling code may decide to fling or otherwise release the view to let
         * it settle into place. It should do so using
         * {@link #settleCapturedViewAt(int, int)} or
         * {@link #flingCapturedView(int, int, int, int)}. If the Callback
         * invokes one of these methods, the ViewDragHelper will enter
         * {@link #STATE_SETTLING} and the view capture will not fully end until
         * it comes to a complete stop. If neither of these methods is invoked
         * before &lt;code&gt;onViewReleased&lt;/code&gt; returns, the view will stop in
         * place and the ViewDragHelper will return to {@link #STATE_IDLE}.
         * &lt;/p&gt;
         *
         * @param releasedChild The captured child view now being released
         * @param xvel          X velocity of the pointer as it left the screen in pixels
         *                      per second.
         * @param yvel          Y velocity of the pointer as it left the screen in pixels
         *                      per second.
         */</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>onViewReleased</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>releasedChild</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>xvel</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>yvel</name></decl></parameter>)</parameter_list> <block>{
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called when one of the subscribed edges in the parent view has been
         * touched by the user while no child view is currently captured.
         *
         * @param edgeFlags A combination of edge flags describing the edge(s)
         *                  currently touched
         * @param pointerId ID of the pointer touching the described edge(s)
         * @see #EDGE_LEFT
         * @see #EDGE_TOP
         * @see #EDGE_RIGHT
         * @see #EDGE_BOTTOM
         */</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>onEdgeTouched</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>edgeFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called when the given edge may become locked. This can happen if an
         * edge drag was preliminarily rejected before beginning, but after
         * {@link #onEdgeTouched(int, int)} was called. This method should
         * return true to lock this edge or false to leave it unlocked. The
         * default behavior is to leave edges unlocked.
         *
         * @param edgeFlags A combination of edge flags describing the edge(s)
         *                  locked
         * @return true to lock the edge, false to leave it unlocked
         */</comment>
        <function><specifier>public</specifier> <type><name>boolean</name></type> <name>onEdgeLock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>edgeFlags</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called when the user has started a deliberate drag away from one of
         * the subscribed edges in the parent view while no child view is
         * currently captured.
         *
         * @param edgeFlags A combination of edge flags describing the edge(s)
         *                  dragged
         * @param pointerId ID of the pointer touching the described edge(s)
         * @see #EDGE_LEFT
         * @see #EDGE_TOP
         * @see #EDGE_RIGHT
         * @see #EDGE_BOTTOM
         */</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>onEdgeDragStarted</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>edgeFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called to determine the Z-order of child views.
         *
         * @param index the ordered position to query for
         * @return index of the view that should be ordered at position
         * &lt;code&gt;index&lt;/code&gt;
         */</comment>
        <function><specifier>public</specifier> <type><name>int</name></type> <name>getOrderedChildIndex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><name>index</name></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Return the magnitude of a draggable child view's horizontal range of
         * motion in pixels. This method should return 0 for views that cannot
         * move horizontally.
         *
         * @param child Child view to check
         * @return range of horizontal motion in pixels
         */</comment>
        <function><specifier>public</specifier> <type><name>int</name></type> <name>getViewHorizontalDragRange</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Return the magnitude of a draggable child view's vertical range of
         * motion in pixels. This method should return 0 for views that cannot
         * move vertically.
         *
         * @param child Child view to check
         * @return range of vertical motion in pixels
         */</comment>
        <function><specifier>public</specifier> <type><name>int</name></type> <name>getViewVerticalDragRange</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Called when the user's input indicates that they want to capture the
         * given child view with the pointer indicated by pointerId. The
         * callback should return true if the user is permitted to drag the
         * given view with the indicated pointer.
         * &lt;p&gt;
         * ViewDragHelper may call this method multiple times for the same view
         * even if the view is already captured; this indicates that a new
         * pointer is trying to take control of the view.
         * &lt;/p&gt;
         * &lt;p&gt;
         * If this method returns true, a call to
         * {@link #onViewCaptured(android.view.View, int)} will follow if the
         * capture is successful.
         * &lt;/p&gt;
         *
         * @param child     Child the user is attempting to capture
         * @param pointerId ID of the pointer attempting the capture
         * @return true if capture should be allowed, false otherwise
         */</comment>
        <function_decl><specifier>public</specifier> <specifier>abstract</specifier> <type><name>boolean</name></type> <name>tryCaptureView</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list>;</function_decl>

        <comment type="block" format="javadoc">/**
         * Restrict the motion of the dragged child view along the horizontal
         * axis. The default implementation does not allow horizontal motion;
         * the extending class must override this method and provide the desired
         * clamping.
         *
         * @param child Child view being dragged
         * @param left  Attempted motion along the X axis
         * @param dx    Proposed change in position for left
         * @return The new clamped position for left
         */</comment>
        <function><specifier>public</specifier> <type><name>int</name></type> <name>clampViewPositionHorizontal</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dx</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></function>

        <comment type="block" format="javadoc">/**
         * Restrict the motion of the dragged child view along the vertical
         * axis. The default implementation does not allow vertical motion; the
         * extending class must override this method and provide the desired
         * clamping.
         *
         * @param child Child view being dragged
         * @param top   Attempted motion along the Y axis
         * @param dy    Proposed change in position for top
         * @return The new clamped position for top
         */</comment>
        <function><specifier>public</specifier> <type><name>int</name></type> <name>clampViewPositionVertical</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dy</name></decl></parameter>)</parameter_list> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Interpolator defining the animation curve for mScroller
     */</comment>
    <decl_stmt><decl><specifier>private</specifier> <specifier>static</specifier> <type><specifier>final</specifier> <name>Interpolator</name></type> <name>sInterpolator</name> <init>= <expr><operator>new</operator> <class><super><name>Interpolator</name></super><argument_list>()</argument_list> <block>{
        <function><specifier>public</specifier> <type><name>float</name></type> <name>getInterpolation</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{
            <expr_stmt><expr><name>t</name> <operator>-=</operator> <literal type="number">1.0f</literal></expr>;</expr_stmt>
            <return>return <expr><name>t</name> <operator>*</operator> <name>t</name> <operator>*</operator> <name>t</name> <operator>*</operator> <name>t</name> <operator>*</operator> <name>t</name> <operator>+</operator> <literal type="number">1.0f</literal></expr>;</return>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><specifier>private</specifier> <type><specifier>final</specifier> <name>Runnable</name></type> <name>mSetIdleRunnable</name> <init>= <expr><operator>new</operator> <class><super><name>Runnable</name></super><argument_list>()</argument_list> <block>{
        <function><specifier>public</specifier> <type><name>void</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Factory method to create a new ViewDragHelper.
     *
     * @param forParent Parent view to monitor
     * @param cb        Callback to provide information and receive events
     * @return a new ViewDragHelper instance
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>ViewDragHelper</name></type> <name>create</name><parameter_list>(<parameter><decl><type><name>ViewGroup</name></type> <name>forParent</name></decl></parameter>, <parameter><decl><type><name>Callback</name></type> <name>cb</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>new</operator> <call><name>ViewDragHelper</name><argument_list>(<argument><expr><call><name><name>forParent</name><operator>.</operator><name>getContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>forParent</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Factory method to create a new ViewDragHelper.
     *
     * @param forParent   Parent view to monitor
     * @param sensitivity Multiplier for how sensitive the helper should be
     *                    about detecting the start of a drag. Larger values are more
     *                    sensitive. 1.0f is normal.
     * @param cb          Callback to provide information and receive events
     * @return a new ViewDragHelper instance
     */</comment>
    <function><specifier>public</specifier> <specifier>static</specifier> <type><name>ViewDragHelper</name></type> <name>create</name><parameter_list>(<parameter><decl><type><name>ViewGroup</name></type> <name>forParent</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>sensitivity</name></decl></parameter>, <parameter><decl><type><name>Callback</name></type> <name>cb</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>ViewDragHelper</name></type> <name>helper</name> <init>= <expr><call><name>create</name><argument_list>(<argument><expr><name>forParent</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>helper</name><operator>.</operator><name>mTouchSlop</name></name> <operator>=</operator> <call>(<name>int</name>) <argument_list>(<argument><expr><name><name>helper</name><operator>.</operator><name>mTouchSlop</name></name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>/</operator> <name>sensitivity</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>helper</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Apps should use ViewDragHelper.create() to get a new instance. This will
     * allow VDH to use internal compatibility implementations for different
     * platform versions.
     *
     * @param context   Context to initialize config-dependent params from
     * @param forParent Parent view to monitor
     */</comment>
    <constructor><specifier>private</specifier> <name>ViewDragHelper</name><parameter_list>(<parameter><decl><type><name>Context</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>ViewGroup</name></type> <name>forParent</name></decl></parameter>, <parameter><decl><type><name>Callback</name></type> <name>cb</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>forParent</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Parent view may not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <if>if <condition>(<expr><name>cb</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Callback may not be null"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <expr_stmt><expr><name>mParentView</name> <operator>=</operator> <name>forParent</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mCallback</name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>ViewConfiguration</name></type> <name>vc</name> <init>= <expr><call><name><name>ViewConfiguration</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>density</name> <init>= <expr><call><name><name>context</name><operator>.</operator><name>getResources</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDisplayMetrics</name><argument_list>()</argument_list></call><operator>.</operator><name>density</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>mEdgeSize</name> <operator>=</operator> <call>(<name>int</name>) <argument_list>(<argument><expr><name>EDGE_SIZE</name> <operator>*</operator> <name>density</name> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mTouchSlop</name> <operator>=</operator> <call><name><name>vc</name><operator>.</operator><name>getScaledTouchSlop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mMaxVelocity</name> <operator>=</operator> <call><name><name>vc</name><operator>.</operator><name>getScaledMaximumFlingVelocity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mMinVelocity</name> <operator>=</operator> <call><name><name>vc</name><operator>.</operator><name>getScaledMinimumFlingVelocity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mScroller</name> <operator>=</operator> <call><name><name>ScrollerCompat</name><operator>.</operator><name>create</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>sInterpolator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <comment type="block" format="javadoc">/**
     * Sets the sensitivity of the dragger.
     *
     * @param context     The application context.
     * @param sensitivity value between 0 and 1, the final value for touchSlop =
     *                    ViewConfiguration.getScaledTouchSlop * (1 / s);
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setSensitivity</name><parameter_list>(<parameter><decl><type><name>Context</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>sensitivity</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>float</name></type> <name>s</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">0f</literal></expr></argument>, <argument><expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">1.0f</literal></expr></argument>, <argument><expr><name>sensitivity</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ViewConfiguration</name></type> <name>viewConfiguration</name> <init>= <expr><call><name><name>ViewConfiguration</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>mTouchSlop</name> <operator>=</operator> <call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>viewConfiguration</name><operator>.</operator><name>getScaledTouchSlop</name></name><argument_list>()</argument_list></call> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>/</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Set the minimum velocity that will be detected as having a magnitude
     * greater than zero in pixels per second. Callback methods accepting a
     * velocity will be clamped appropriately.
     *
     * @param minVel minimum velocity to detect
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setMinVelocity</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>minVel</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>mMinVelocity</name> <operator>=</operator> <name>minVel</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Set the max velocity that will be detected as having a magnitude
     * greater than zero in pixels per second. Callback methods accepting a
     * velocity will be clamped appropriately.
     *
     * @param maxVel max velocity to detect
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setMaxVelocity</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>maxVel</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>mMaxVelocity</name> <operator>=</operator> <name>maxVel</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Return the currently configured minimum velocity. Any flings with a
     * magnitude less than this value in pixels per second. Callback methods
     * accepting a velocity will receive zero as a velocity value if the real
     * detected velocity was below this threshold.
     *
     * @return the minimum velocity that will be detected
     */</comment>
    <function><specifier>public</specifier> <type><name>float</name></type> <name>getMinVelocity</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mMinVelocity</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Retrieve the current drag state of this helper. This will return one of
     * {@link #STATE_IDLE}, {@link #STATE_DRAGGING} or {@link #STATE_SETTLING}.
     *
     * @return The current drag state
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>getViewDragState</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mDragState</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Enable edge tracking for the selected edges of the parent view. The
     * callback's
     * {@link me.imid.swipebacklayout.lib.ViewDragHelper.Callback#onEdgeTouched(int, int)}
     * and
     * {@link me.imid.swipebacklayout.lib.ViewDragHelper.Callback#onEdgeDragStarted(int, int)}
     * methods will only be invoked for edges for which edge tracking has been
     * enabled.
     *
     * @param edgeFlags Combination of edge flags describing the edges to watch
     * @see #EDGE_LEFT
     * @see #EDGE_TOP
     * @see #EDGE_RIGHT
     * @see #EDGE_BOTTOM
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setEdgeTrackingEnabled</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>edgeFlags</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>mTrackingEdges</name> <operator>=</operator> <name>edgeFlags</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Return the size of an edge. This is the range in pixels along the edges
     * of this view that will actively detect edge touches or drags if edge
     * tracking is enabled.
     *
     * @return The size of an edge in pixels
     * @see #setEdgeTrackingEnabled(int)
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>getEdgeSize</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mEdgeSize</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Set the size of an edge. This is the range in pixels along the edges of
     * this view that will actively detect edge touches or drags if edge
     * tracking is enabled.
     *
     * @param size The size of an edge in pixels
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>setEdgeSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>mEdgeSize</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Capture a specific child view for dragging within the parent. The
     * callback will be notified but
     * {@link me.imid.swipebacklayout.lib.ViewDragHelper.Callback#tryCaptureView(android.view.View, int)}
     * will not be asked permission to capture this view.
     *
     * @param childView       Child view to capture
     * @param activePointerId ID of the pointer that is dragging the captured
     *                        child view
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>captureChildView</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>childView</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>activePointerId</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><call><name><name>childView</name><operator>.</operator><name>getParent</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>mParentView</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"captureChildView: parameter must be a descendant "</literal>
                    <operator>+</operator> <literal type="string">"of the ViewDragHelper's tracked parent view ("</literal> <operator>+</operator> <name>mParentView</name> <operator>+</operator> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <expr_stmt><expr><name>mCapturedView</name> <operator>=</operator> <name>childView</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mActivePointerId</name> <operator>=</operator> <name>activePointerId</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onViewCaptured</name></name><argument_list>(<argument><expr><name>childView</name></expr></argument>, <argument><expr><name>activePointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_DRAGGING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return The currently captured view, or null if no view has been
     * captured.
     */</comment>
    <function><specifier>public</specifier> <type><name>View</name></type> <name>getCapturedView</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mCapturedView</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return The ID of the pointer currently dragging the captured view, or
     * {@link #INVALID_POINTER}.
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>getActivePointerId</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mActivePointerId</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return The minimum distance in pixels that the user must travel to
     * initiate a drag
     */</comment>
    <function><specifier>public</specifier> <type><name>int</name></type> <name>getTouchSlop</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mTouchSlop</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * The result of a call to this method is equivalent to
     * {@link #processTouchEvent(android.view.MotionEvent)} receiving an
     * ACTION_CANCEL event.
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>cancel</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>mActivePointerId</name> <operator>=</operator> <name>INVALID_POINTER</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clearMotionHistory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>mVelocityTracker</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>mVelocityTracker</name><operator>.</operator><name>recycle</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mVelocityTracker</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * {@link #cancel()}, but also abort all motion in progress and snap to the
     * end of any animation.
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>abort</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>cancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_SETTLING</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>oldX</name> <init>= <expr><call><name><name>mScroller</name><operator>.</operator><name>getCurrX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>oldY</name> <init>= <expr><call><name><name>mScroller</name><operator>.</operator><name>getCurrY</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>mScroller</name><operator>.</operator><name>abortAnimation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newX</name> <init>= <expr><call><name><name>mScroller</name><operator>.</operator><name>getCurrX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>newY</name> <init>= <expr><call><name><name>mScroller</name><operator>.</operator><name>getCurrY</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onViewPositionChanged</name></name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>newX</name></expr></argument>, <argument><expr><name>newY</name></expr></argument>, <argument><expr><name>newX</name> <operator>-</operator> <name>oldX</name></expr></argument>, <argument><expr><name>newY</name> <operator>-</operator> <name>oldY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position. If
     * this method returns true, the caller should invoke
     * {@link #continueSettling(boolean)} on each subsequent frame to continue
     * the motion until it returns false. If this method returns false there is
     * no further work to do to complete the movement.
     * &lt;p&gt;
     * This operation does not count as a capture event, though
     * {@link #getCapturedView()} will still report the sliding view while the
     * slide is in progress.
     * &lt;/p&gt;
     *
     * @param child     Child view to capture and animate
     * @param finalLeft Final left position of child
     * @param finalTop  Final top position of child
     * @return true if animation should continue through
     * {@link #continueSettling(boolean)} calls
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>smoothSlideViewTo</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>finalLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>finalTop</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>mCapturedView</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mActivePointerId</name> <operator>=</operator> <name>INVALID_POINTER</name></expr>;</expr_stmt>

        <return>return <expr><call><name>forceSettleCapturedViewAt</name><argument_list>(<argument><expr><name>finalLeft</name></expr></argument>, <argument><expr><name>finalTop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Settle the captured view at the given (left, top) position. The
     * appropriate velocity from prior motion will be taken into account. If
     * this method returns true, the caller should invoke
     * {@link #continueSettling(boolean)} on each subsequent frame to continue
     * the motion until it returns false. If this method returns false there is
     * no further work to do to complete the movement.
     *
     * @param finalLeft Settled left edge position for the captured view
     * @param finalTop  Settled top edge position for the captured view
     * @return true if animation should continue through
     * {@link #continueSettling(boolean)} calls
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>settleCapturedViewAt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>finalLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>finalTop</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>!</operator><name>mReleaseInProgress</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Cannot settleCapturedViewAt outside of a call to "</literal>
                    <operator>+</operator> <literal type="string">"Callback#onViewReleased"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <return>return <expr><call><name>forceSettleCapturedViewAt</name><argument_list>(<argument><expr><name>finalLeft</name></expr></argument>, <argument><expr><name>finalTop</name></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>VelocityTrackerCompat</name><operator>.</operator><name>getXVelocity</name></name><argument_list>(<argument><expr><name>mVelocityTracker</name></expr></argument>, <argument><expr><name>mActivePointerId</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>VelocityTrackerCompat</name><operator>.</operator><name>getYVelocity</name></name><argument_list>(<argument><expr><name>mVelocityTracker</name></expr></argument>, <argument><expr><name>mActivePointerId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Settle the captured view at the given (left, top) position.
     *
     * @param finalLeft Target left position for the captured view
     * @param finalTop  Target top position for the captured view
     * @param xvel      Horizontal velocity
     * @param yvel      Vertical velocity
     * @return true if animation should continue through
     * {@link #continueSettling(boolean)} calls
     */</comment>
    <function><specifier>private</specifier> <type><name>boolean</name></type> <name>forceSettleCapturedViewAt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>finalLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>finalTop</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xvel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yvel</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>startLeft</name> <init>= <expr><call><name><name>mCapturedView</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>startTop</name> <init>= <expr><call><name><name>mCapturedView</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>dx</name> <init>= <expr><name>finalLeft</name> <operator>-</operator> <name>startLeft</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>dy</name> <init>= <expr><name>finalTop</name> <operator>-</operator> <name>startTop</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>dx</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dy</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <comment type="line">// Nothing to do. Send callbacks, be done.</comment>
            <expr_stmt><expr><call><name><name>mScroller</name><operator>.</operator><name>abortAnimation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>duration</name> <init>= <expr><call><name>computeSettleDuration</name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>xvel</name></expr></argument>, <argument><expr><name>yvel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mScroller</name><operator>.</operator><name>startScroll</name></name><argument_list>(<argument><expr><name>startLeft</name></expr></argument>, <argument><expr><name>startTop</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_SETTLING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    }</block></function>

    <function><specifier>private</specifier> <type><name>int</name></type> <name>computeSettleDuration</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xvel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yvel</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>xvel</name> <operator>=</operator> <call><name>clampMag</name><argument_list>(<argument><expr><name>xvel</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>mMinVelocity</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>mMaxVelocity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>yvel</name> <operator>=</operator> <call><name>clampMag</name><argument_list>(<argument><expr><name>yvel</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>mMinVelocity</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>mMaxVelocity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>absDx</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>absDy</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>absXVel</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>xvel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>absYVel</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>yvel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>addedVel</name> <init>= <expr><name>absXVel</name> <operator>+</operator> <name>absYVel</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>addedDistance</name> <init>= <expr><name>absDx</name> <operator>+</operator> <name>absDy</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>xweight</name> <init>= <expr><ternary><condition><expr><name>xvel</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>float</name><operator>)</operator> <name>absXVel</name> <operator>/</operator> <name>addedVel</name></expr> </then><else>: <expr><operator>(</operator><name>float</name><operator>)</operator> <name>absDx</name>
                <operator>/</operator> <name>addedDistance</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>yweight</name> <init>= <expr><ternary><condition><expr><name>yvel</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>float</name><operator>)</operator> <name>absYVel</name> <operator>/</operator> <name>addedVel</name></expr> </then><else>: <expr><operator>(</operator><name>float</name><operator>)</operator> <name>absDy</name>
                <operator>/</operator> <name>addedDistance</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>xduration</name> <init>= <expr><call><name>computeAxisDuration</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>xvel</name></expr></argument>, <argument><expr><call><name><name>mCallback</name><operator>.</operator><name>getViewHorizontalDragRange</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>yduration</name> <init>= <expr><call><name>computeAxisDuration</name><argument_list>(<argument><expr><name>dy</name></expr></argument>, <argument><expr><name>yvel</name></expr></argument>, <argument><expr><call><name><name>mCallback</name><operator>.</operator><name>getViewVerticalDragRange</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>xduration</name> <operator>*</operator> <name>xweight</name> <operator>+</operator> <name>yduration</name> <operator>*</operator> <name>yweight</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><specifier>private</specifier> <type><name>int</name></type> <name>computeAxisDuration</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>velocity</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>motionRange</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>delta</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>width</name> <init>= <expr><call><name><name>mParentView</name><operator>.</operator><name>getWidth</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>halfWidth</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>distanceRatio</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><literal type="number">1f</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator> <call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>distance</name> <init>= <expr><name>halfWidth</name> <operator>+</operator> <name>halfWidth</name>
                <operator>*</operator> <call><name>distanceInfluenceForSnapDuration</name><argument_list>(<argument><expr><name>distanceRatio</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>duration</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>velocity</name> <operator>=</operator> <call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>velocity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>velocity</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>duration</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <call><name><name>Math</name><operator>.</operator><name>round</name></name><argument_list>(<argument><expr><literal type="number">1000</literal> <operator>*</operator> <call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>distance</name> <operator>/</operator> <name>velocity</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>range</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator> <call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>motionRange</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>duration</name> <operator>=</operator> <call>(<name>int</name>) <argument_list>(<argument><expr><operator>(</operator><name>range</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>BASE_SETTLE_DURATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><call><name><name>Math</name><operator>.</operator><name>min</name></name><argument_list>(<argument><expr><name>duration</name></expr></argument>, <argument><expr><name>MAX_SETTLE_DURATION</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Clamp the magnitude of value for absMin and absMax. If the value is below
     * the minimum, it will be clamped to zero. If the value is above the
     * maximum, it will be clamped to the maximum.
     *
     * @param value  Value to clamp
     * @param absMin Absolute value of the minimum significant value to return
     * @param absMax Absolute value of the maximum value to return
     * @return The clamped value with the same sign as &lt;code&gt;value&lt;/code&gt;
     */</comment>
    <function><specifier>private</specifier> <type><name>int</name></type> <name>clampMag</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>absMin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>absMax</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>absValue</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>absValue</name> <operator>&lt;</operator> <name>absMin</name></expr>)</condition><then>
            <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>
        <if>if <condition>(<expr><name>absValue</name> <operator>&gt;</operator> <name>absMax</name></expr>)</condition><then>
            <block type="pseudo"><return>return <expr><ternary><condition><expr><name>value</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>absMax</name></expr> </then><else>: <expr><operator>-</operator><name>absMax</name></expr></else></ternary></expr>;</return></block></then></if>
        <return>return <expr><name>value</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Clamp the magnitude of value for absMin and absMax. If the value is below
     * the minimum, it will be clamped to zero. If the value is above the
     * maximum, it will be clamped to the maximum.
     *
     * @param value  Value to clamp
     * @param absMin Absolute value of the minimum significant value to return
     * @param absMax Absolute value of the maximum value to return
     * @return The clamped value with the same sign as &lt;code&gt;value&lt;/code&gt;
     */</comment>
    <function><specifier>private</specifier> <type><name>float</name></type> <name>clampMag</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>absMin</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>absMax</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>absValue</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>absValue</name> <operator>&lt;</operator> <name>absMin</name></expr>)</condition><then>
            <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>
        <if>if <condition>(<expr><name>absValue</name> <operator>&gt;</operator> <name>absMax</name></expr>)</condition><then>
            <block type="pseudo"><return>return <expr><ternary><condition><expr><name>value</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>absMax</name></expr> </then><else>: <expr><operator>-</operator><name>absMax</name></expr></else></ternary></expr>;</return></block></then></if>
        <return>return <expr><name>value</name></expr>;</return>
    }</block></function>

    <function><specifier>private</specifier> <type><name>float</name></type> <name>distanceInfluenceForSnapDuration</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>f</name> <operator>-=</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt> <comment type="line">// center the values about 0.</comment>
        <expr_stmt><expr><name>f</name> <operator>*=</operator> <literal type="number">0.3f</literal> <operator>*</operator> <name><name>Math</name><operator>.</operator><name>PI</name></name> <operator>/</operator> <literal type="number">2.0f</literal></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>float</name><operator>)</operator> <call><name><name>Math</name><operator>.</operator><name>sin</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Settle the captured view based on standard free-moving fling behavior.
     * The caller should invoke {@link #continueSettling(boolean)} on each
     * subsequent frame to continue the motion until it returns false.
     *
     * @param minLeft Minimum X position for the view's left edge
     * @param minTop  Minimum Y position for the view's top edge
     * @param maxLeft Maximum X position for the view's left edge
     * @param maxTop  Maximum Y position for the view's top edge
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>flingCapturedView</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minTop</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxTop</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>!</operator><name>mReleaseInProgress</name></expr>)</condition><then> <block>{
            <throw>throw <expr><operator>new</operator> <call><name>IllegalStateException</name><argument_list>(<argument><expr><literal type="string">"Cannot flingCapturedView outside of a call to "</literal>
                    <operator>+</operator> <literal type="string">"Callback#onViewReleased"</literal></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>mScroller</name><operator>.</operator><name>fling</name></name><argument_list>(<argument><expr><call><name><name>mCapturedView</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>mCapturedView</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>VelocityTrackerCompat</name><operator>.</operator><name>getXVelocity</name></name><argument_list>(<argument><expr><name>mVelocityTracker</name></expr></argument>, <argument><expr><name>mActivePointerId</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>VelocityTrackerCompat</name><operator>.</operator><name>getYVelocity</name></name><argument_list>(<argument><expr><name>mVelocityTracker</name></expr></argument>, <argument><expr><name>mActivePointerId</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>minLeft</name></expr></argument>, <argument><expr><name>maxLeft</name></expr></argument>, <argument><expr><name>minTop</name></expr></argument>, <argument><expr><name>maxTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_SETTLING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Move the captured settling view by the appropriate amount for the current
     * time. If &lt;code&gt;continueSettling&lt;/code&gt; returns true, the caller should
     * call it again on the next frame to continue.
     *
     * @param deferCallbacks true if state callbacks should be deferred via
     *                       posted message. Set this to true if you are calling this
     *                       method from {@link android.view.View#computeScroll()} or
     *                       similar methods invoked as part of layout or drawing.
     * @return true if settle is still in progress
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>continueSettling</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>deferCallbacks</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_SETTLING</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>keepGoing</name> <init>= <expr><call><name><name>mScroller</name><operator>.</operator><name>computeScrollOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>x</name> <init>= <expr><call><name><name>mScroller</name><operator>.</operator><name>getCurrX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>y</name> <init>= <expr><call><name><name>mScroller</name><operator>.</operator><name>getCurrY</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>dx</name> <init>= <expr><name>x</name> <operator>-</operator> <call><name><name>mCapturedView</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>dy</name> <init>= <expr><name>y</name> <operator>-</operator> <call><name><name>mCapturedView</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>dx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>mCapturedView</name><operator>.</operator><name>offsetLeftAndRight</name></name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>dy</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>mCapturedView</name><operator>.</operator><name>offsetTopAndBottom</name></name><argument_list>(<argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>dx</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>dy</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onViewPositionChanged</name></name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>keepGoing</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>==</operator> <call><name><name>mScroller</name><operator>.</operator><name>getFinalX</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>y</name> <operator>==</operator> <call><name><name>mScroller</name><operator>.</operator><name>getFinalY</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// Close enough. The interpolator/scroller might think we're</comment>
                <comment type="line">// still moving</comment>
                <comment type="line">// but the user sure doesn't.</comment>
                <expr_stmt><expr><call><name><name>mScroller</name><operator>.</operator><name>abortAnimation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>keepGoing</name> <operator>=</operator> <call><name><name>mScroller</name><operator>.</operator><name>isFinished</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><operator>!</operator><name>keepGoing</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>deferCallbacks</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>mParentView</name><operator>.</operator><name>post</name></name><argument_list>(<argument><expr><name>mSetIdleRunnable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>
        }</block></then></if>

        <return>return <expr><name>mDragState</name> <operator>==</operator> <name>STATE_SETTLING</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Like all callback events this must happen on the UI thread, but release
     * involves some extra semantics. During a release (mReleaseInProgress) is
     * the only time it is valid to call {@link #settleCapturedViewAt(int, int)}
     * or {@link #flingCapturedView(int, int, int, int)}.
     */</comment>
    <function><specifier>private</specifier> <type><name>void</name></type> <name>dispatchViewReleased</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>xvel</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>yvel</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><name>mReleaseInProgress</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onViewReleased</name></name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>xvel</name></expr></argument>, <argument><expr><name>yvel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mReleaseInProgress</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name></expr>)</condition><then> <block>{
            <comment type="line">// onViewReleased didn't call a method that would have changed this.</comment>
            <comment type="line">// Go idle.</comment>
            <expr_stmt><expr><call><name>setDragState</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>clearMotionHistory</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>mInitialMotionX</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>mInitialMotionX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>mInitialMotionY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>mLastMotionX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>mLastMotionY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>mInitialEdgeTouched</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>mEdgeDragsInProgress</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Arrays</name><operator>.</operator><name>fill</name></name><argument_list>(<argument><expr><name>mEdgeDragsLocked</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPointersDown</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>clearMotionHistory</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>mInitialMotionX</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>mInitialMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mInitialMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mLastMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mLastMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mEdgeDragsInProgress</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mEdgeDragsLocked</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPointersDown</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>pointerId</name><operator>)</operator></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>ensureMotionHistorySizeForId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>mInitialMotionX</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>mInitialMotionX</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <name>pointerId</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>float</name><index>[]</index></name></type> <name>imx</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name>pointerId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>float</name><index>[]</index></name></type> <name>imy</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name>pointerId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>float</name><index>[]</index></name></type> <name>lmx</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name>pointerId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>float</name><index>[]</index></name></type> <name>lmy</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><name>pointerId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>iit</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>pointerId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>edip</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>pointerId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>edl</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><name>pointerId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>mInitialMotionX</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>mInitialMotionX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>imx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mInitialMotionX</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>mInitialMotionY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>imy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mInitialMotionY</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>mLastMotionX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lmx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mLastMotionX</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>mLastMotionY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lmy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mLastMotionY</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>mInitialEdgeTouched</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mInitialEdgeTouched</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>mEdgeDragsInProgress</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>edip</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mEdgeDragsInProgress</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name>mEdgeDragsLocked</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>edl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>mEdgeDragsLocked</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>mInitialMotionX</name> <operator>=</operator> <name>imx</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mInitialMotionY</name> <operator>=</operator> <name>imy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mLastMotionX</name> <operator>=</operator> <name>lmx</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mLastMotionY</name> <operator>=</operator> <name>lmy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mInitialEdgeTouched</name> <operator>=</operator> <name>iit</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mEdgeDragsInProgress</name> <operator>=</operator> <name>edip</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>mEdgeDragsLocked</name> <operator>=</operator> <name>edl</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>saveInitialMotion</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>ensureMotionHistorySizeForId</name><argument_list>(<argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mInitialMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <name><name>mLastMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mInitialMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <name><name>mLastMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <call><name>getEdgeTouched</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPointersDown</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>pointerId</name></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>saveLastMotion</name><parameter_list>(<parameter><decl><type><name>MotionEvent</name></type> <name>ev</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerCount</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerCount</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pointerCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getX</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getY</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>mLastMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mLastMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if the given pointer ID represents a pointer that is currently down
     * (to the best of the ViewDragHelper's knowledge).
     * &lt;p&gt;
     * The state used to report this information is populated by the methods
     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or
     * {@link #processTouchEvent(android.view.MotionEvent)}. If one of these
     * methods has not been called for all relevant MotionEvents to track, the
     * information reported by this method may be stale or incorrect.
     * &lt;/p&gt;
     *
     * @param pointerId pointer ID to check; corresponds to IDs provided by
     *                  MotionEvent
     * @return true if the pointer with the given ID is still down
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isPointerDown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><operator>(</operator><name>mPointersDown</name> <operator>&amp;</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>pointerId</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name>setDragState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>mDragState</name> <operator>!=</operator> <name>state</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mDragState</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onViewDragStateChanged</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>STATE_IDLE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>mCapturedView</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Attempt to capture the view with the given pointer ID. The callback will
     * be involved. This will put us into the "dragging" state. If we've already
     * captured this view with this pointer this method will immediately return
     * true without consulting the callback.
     *
     * @param toCapture View to capture
     * @param pointerId Pointer to capture with
     * @return true if capture was successful
     */</comment>
    <function><type><name>boolean</name></type> <name>tryCaptureViewForDrag</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>toCapture</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>toCapture</name> <operator>==</operator> <name>mCapturedView</name> <operator>&amp;&amp;</operator> <name>mActivePointerId</name> <operator>==</operator> <name>pointerId</name></expr>)</condition><then> <block>{
            <comment type="line">// Already done!</comment>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>toCapture</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>mCallback</name><operator>.</operator><name>tryCaptureView</name></name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mActivePointerId</name> <operator>=</operator> <name>pointerId</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>captureChildView</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Tests scrollability within child views of v given a delta of dx.
     *
     * @param v      View to test for horizontal scrollability
     * @param checkV Whether the view v passed should itself be checked for
     *               scrollability (true), or just its children (false).
     * @param dx     Delta scrolled in pixels along the X axis
     * @param dy     Delta scrolled in pixels along the Y axis
     * @param x      X coordinate of the active touch point
     * @param y      Y coordinate of the active touch point
     * @return true if child views of v can be scrolled by delta of dx.
     */</comment>
    <function><specifier>protected</specifier> <type><name>boolean</name></type> <name>canScroll</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>boolean</name></type> <name>checkV</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>v</name> <operator>instanceof</operator> <name>ViewGroup</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>ViewGroup</name></type> <name>group</name> <init>= <expr><operator>(</operator><name>ViewGroup</name><operator>)</operator> <name>v</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>scrollX</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getScrollX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>scrollY</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>getScrollY</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name> <init>= <expr><call><name><name>group</name><operator>.</operator><name>getChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// Count backwards - let topmost views consume scroll distance</comment>
            <comment type="line">// first.</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
                <comment type="line">// TODO: Add versioned support here for transformed views.</comment>
                <comment type="line">// This will not work for transformed views in Honeycomb+</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>child</name> <init>= <expr><call><name><name>group</name><operator>.</operator><name>getChildAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>x</name> <operator>+</operator> <name>scrollX</name> <operator>&gt;=</operator> <call><name><name>child</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call>
                        <operator>&amp;&amp;</operator> <name>x</name> <operator>+</operator> <name>scrollX</name> <operator>&lt;</operator> <call><name><name>child</name><operator>.</operator><name>getRight</name></name><argument_list>()</argument_list></call>
                        <operator>&amp;&amp;</operator> <name>y</name> <operator>+</operator> <name>scrollY</name> <operator>&gt;=</operator> <call><name><name>child</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call>
                        <operator>&amp;&amp;</operator> <name>y</name> <operator>+</operator> <name>scrollY</name> <operator>&lt;</operator> <call><name><name>child</name><operator>.</operator><name>getBottom</name></name><argument_list>()</argument_list></call>
                        <operator>&amp;&amp;</operator> <call><name>canScroll</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>x</name> <operator>+</operator> <name>scrollX</name> <operator>-</operator> <call><name><name>child</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>y</name>
                        <operator>+</operator> <name>scrollY</name> <operator>-</operator> <call><name><name>child</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                }</block></then></if>
            }</block></for>
        }</block></then></if>

        <return>return <expr><name>checkV</name>
                <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>ViewCompat</name><operator>.</operator><name>canScrollHorizontally</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><name>dx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>ViewCompat</name><operator>.</operator><name>canScrollVertically</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>,
                <argument><expr><operator>-</operator><name>dy</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if this event as provided to the parent view's
     * onInterceptTouchEvent should cause the parent to intercept the touch
     * event stream.
     *
     * @param ev MotionEvent provided to onInterceptTouchEvent
     * @return true if the parent view should return true from
     * onInterceptTouchEvent
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>shouldInterceptTouchEvent</name><parameter_list>(<parameter><decl><type><name>MotionEvent</name></type> <name>ev</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>action</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getActionMasked</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>actionIndex</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getActionIndex</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>action</name> <operator>==</operator> <name><name>MotionEvent</name><operator>.</operator><name>ACTION_DOWN</name></name></expr>)</condition><then> <block>{
            <comment type="line">// Reset things for a new event stream, just in case we didn't get</comment>
            <comment type="line">// the whole previous stream.</comment>
            <expr_stmt><expr><call><name>cancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>mVelocityTracker</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mVelocityTracker</name> <operator>=</operator> <call><name><name>VelocityTracker</name><operator>.</operator><name>obtain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>mVelocityTracker</name><operator>.</operator><name>addMovement</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>action</name></expr>)</condition> <block>{
            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_DOWN</name></name></expr>:</case> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>ev</name><operator>.</operator><name>getX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>ev</name><operator>.</operator><name>getY</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>saveInitialMotion</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>toCapture</name> <init>= <expr><call><name>findTopChildUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Catch a settling view if possible.</comment>
                <if>if <condition>(<expr><name>toCapture</name> <operator>==</operator> <name>mCapturedView</name> <operator>&amp;&amp;</operator> <name>mDragState</name> <operator>==</operator> <name>STATE_SETTLING</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>edgesTouched</name> <init>= <expr><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>(</operator><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onEdgeTouched</name></name><argument_list>(<argument><expr><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEventCompat</name><operator>.</operator><name>ACTION_POINTER_DOWN</name></name></expr>:</case> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getX</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getY</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>saveInitialMotion</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// A ViewDragHelper can only manipulate one view at a time.</comment>
                <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_IDLE</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>edgesTouched</name> <init>= <expr><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><operator>(</operator><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onEdgeTouched</name></name><argument_list>(<argument><expr><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <elseif>else <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_SETTLING</name></expr>)</condition><then> <block>{
                    <comment type="line">// Catch a settling view if possible.</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>toCapture</name> <init>= <expr><call><name>findTopChildUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>toCapture</name> <operator>==</operator> <name>mCapturedView</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if></elseif></if>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_MOVE</name></name></expr>:</case> <block>{
                <comment type="line">// First to cross a touch slop over a draggable view wins. Also</comment>
                <comment type="line">// report edge drags.</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerCount</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerCount</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pointerCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getX</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getY</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>dx</name> <init>= <expr><name>x</name> <operator>-</operator> <name><name>mInitialMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>dy</name> <init>= <expr><name>y</name> <operator>-</operator> <name><name>mInitialMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>reportNewEdgeDrags</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name></expr>)</condition><then> <block>{
                        <comment type="line">// Callback might have started an edge drag</comment>
                        <break>break;</break>
                    }</block></then></if>

                    <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>toCapture</name> <init>= <expr><call><name>findTopChildUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>toCapture</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name>checkTouchSlop</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>)</argument_list></call>
                            <operator>&amp;&amp;</operator> <call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
                <expr_stmt><expr><call><name>saveLastMotion</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEventCompat</name><operator>.</operator><name>ACTION_POINTER_UP</name></name></expr>:</case> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>clearMotionHistory</name><argument_list>(<argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_UP</name></name></expr>:</case>
            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_CANCEL</name></name></expr>:</case> <block>{
                <expr_stmt><expr><call><name>cancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block>
        }</block></switch>

        <return>return <expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Process a touch event received by the parent view. This method will
     * dispatch callback events as needed before returning. The parent view's
     * onTouchEvent implementation should call this.
     *
     * @param ev The touch event received by the parent view
     */</comment>
    <function><specifier>public</specifier> <type><name>void</name></type> <name>processTouchEvent</name><parameter_list>(<parameter><decl><type><name>MotionEvent</name></type> <name>ev</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>action</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getActionMasked</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>actionIndex</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getActionIndex</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>action</name> <operator>==</operator> <name><name>MotionEvent</name><operator>.</operator><name>ACTION_DOWN</name></name></expr>)</condition><then> <block>{
            <comment type="line">// Reset things for a new event stream, just in case we didn't get</comment>
            <comment type="line">// the whole previous stream.</comment>
            <expr_stmt><expr><call><name>cancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>mVelocityTracker</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mVelocityTracker</name> <operator>=</operator> <call><name><name>VelocityTracker</name><operator>.</operator><name>obtain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>mVelocityTracker</name><operator>.</operator><name>addMovement</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>action</name></expr>)</condition> <block>{
            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_DOWN</name></name></expr>:</case> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>ev</name><operator>.</operator><name>getX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>ev</name><operator>.</operator><name>getY</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>toCapture</name> <init>= <expr><call><name>findTopChildUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>saveInitialMotion</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Since the parent is already directly processing this touch</comment>
                <comment type="line">// event,</comment>
                <comment type="line">// there is no reason to delay for a slop before dragging.</comment>
                <comment type="line">// Start immediately if possible.</comment>
                <expr_stmt><expr><call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>edgesTouched</name> <init>= <expr><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>(</operator><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onEdgeTouched</name></name><argument_list>(<argument><expr><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEventCompat</name><operator>.</operator><name>ACTION_POINTER_DOWN</name></name></expr>:</case> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getX</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getY</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>saveInitialMotion</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// A ViewDragHelper can only manipulate one view at a time.</comment>
                <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_IDLE</name></expr>)</condition><then> <block>{
                    <comment type="line">// If we're idle we can do anything! Treat it like a normal</comment>
                    <comment type="line">// down event.</comment>

                    <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>toCapture</name> <init>= <expr><call><name>findTopChildUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>edgesTouched</name> <init>= <expr><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><operator>(</operator><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onEdgeTouched</name></name><argument_list>(<argument><expr><name>edgesTouched</name> <operator>&amp;</operator> <name>mTrackingEdges</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <elseif>else <if>if <condition>(<expr><call><name>isCapturedViewUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// We're still tracking a captured view. If the same view is</comment>
                    <comment type="line">// under this</comment>
                    <comment type="line">// point, we'll swap to controlling it with this pointer</comment>
                    <comment type="line">// instead.</comment>
                    <comment type="line">// (This will still work if we're "catching" a settling</comment>
                    <comment type="line">// view.)</comment>

                    <expr_stmt><expr><call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></elseif></if>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_MOVE</name></name></expr>:</case> <block>{
                <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>findPointerIndex</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>mActivePointerId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getX</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getY</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>x</name> <operator>-</operator> <name><name>mLastMotionX</name><index>[<expr><name>mActivePointerId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>idy</name> <init>= <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>y</name> <operator>-</operator> <name><name>mLastMotionY</name><index>[<expr><name>mActivePointerId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>dragTo</name><argument_list>(<argument><expr><call><name><name>mCapturedView</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><call><name><name>mCapturedView</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>idy</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>idy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>saveLastMotion</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="line">// Check to see if any pointer is now over a draggable view.</comment>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerCount</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerCount</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pointerCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getX</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getY</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>dx</name> <init>= <expr><name>x</name> <operator>-</operator> <name><name>mInitialMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>dy</name> <init>= <expr><name>y</name> <operator>-</operator> <name><name>mInitialMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>reportNewEdgeDrags</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name></expr>)</condition><then> <block>{
                            <comment type="line">// Callback might have started an edge drag.</comment>
                            <break>break;</break>
                        }</block></then></if>

                        <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>toCapture</name> <init>= <expr><call><name>findTopChildUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>checkTouchSlop</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>)</argument_list></call>
                                <operator>&amp;&amp;</operator> <call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>toCapture</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <break>break;</break>
                        }</block></then></if>
                    }</block></for>
                    <expr_stmt><expr><call><name>saveLastMotion</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEventCompat</name><operator>.</operator><name>ACTION_POINTER_UP</name></name></expr>:</case> <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerId</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>actionIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name> <operator>&amp;&amp;</operator> <name>pointerId</name> <operator>==</operator> <name>mActivePointerId</name></expr>)</condition><then> <block>{
                    <comment type="line">// Try to find another pointer that's still holding on to</comment>
                    <comment type="line">// the captured view.</comment>
                    <decl_stmt><decl><type><name>int</name></type> <name>newActivePointer</name> <init>= <expr><name>INVALID_POINTER</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>pointerCount</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerCount</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pointerCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
                        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>id</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getPointerId</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>mActivePointerId</name></expr>)</condition><then> <block>{
                            <comment type="line">// This one's going away, skip.</comment>
                            <continue>continue;</continue>
                        }</block></then></if>

                        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getX</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>y</name> <init>= <expr><call><name><name>MotionEventCompat</name><operator>.</operator><name>getY</name></name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>findTopChildUnder</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>y</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>mCapturedView</name>
                                <operator>&amp;&amp;</operator> <call><name>tryCaptureViewForDrag</name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>newActivePointer</name> <operator>=</operator> <name>mActivePointerId</name></expr>;</expr_stmt>
                            <break>break;</break>
                        }</block></then></if>
                    }</block></for>

                    <if>if <condition>(<expr><name>newActivePointer</name> <operator>==</operator> <name>INVALID_POINTER</name></expr>)</condition><then> <block>{
                        <comment type="line">// We didn't find another pointer still touching the</comment>
                        <comment type="line">// view, release it.</comment>
                        <expr_stmt><expr><call><name>releaseViewForPointerUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><call><name>clearMotionHistory</name><argument_list>(<argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_UP</name></name></expr>:</case> <block>{
                <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>releaseViewForPointerUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>cancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block>

            <case>case <expr><name><name>MotionEvent</name><operator>.</operator><name>ACTION_CANCEL</name></name></expr>:</case> <block>{
                <if>if <condition>(<expr><name>mDragState</name> <operator>==</operator> <name>STATE_DRAGGING</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>dispatchViewReleased</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>cancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block>
        }</block></switch>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>reportNewEdgeDrags</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>dx</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>dragsStarted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>checkNewEdgeDrag</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>, <argument><expr><name>EDGE_LEFT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dragsStarted</name> <operator>|=</operator> <name>EDGE_LEFT</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>checkNewEdgeDrag</name><argument_list>(<argument><expr><name>dy</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>, <argument><expr><name>EDGE_TOP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dragsStarted</name> <operator>|=</operator> <name>EDGE_TOP</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>checkNewEdgeDrag</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>, <argument><expr><name>EDGE_RIGHT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dragsStarted</name> <operator>|=</operator> <name>EDGE_RIGHT</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>checkNewEdgeDrag</name><argument_list>(<argument><expr><name>dy</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>, <argument><expr><name>EDGE_BOTTOM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dragsStarted</name> <operator>|=</operator> <name>EDGE_BOTTOM</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>dragsStarted</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>mEdgeDragsInProgress</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>|=</operator> <name>dragsStarted</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mCallback</name><operator>.</operator><name>onEdgeDragStarted</name></name><argument_list>(<argument><expr><name>dragsStarted</name></expr></argument>, <argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><specifier>private</specifier> <type><name>boolean</name></type> <name>checkNewEdgeDrag</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>odelta</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>edge</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>absDelta</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>absODelta</name> <init>= <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>odelta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><operator>(</operator><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>&amp;</operator> <name>edge</name><operator>)</operator> <operator>!=</operator> <name>edge</name> <operator>||</operator> <operator>(</operator><name>mTrackingEdges</name> <operator>&amp;</operator> <name>edge</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
                <operator>||</operator> <operator>(</operator><name><name>mEdgeDragsLocked</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>&amp;</operator> <name>edge</name><operator>)</operator> <operator>==</operator> <name>edge</name>
                <operator>||</operator> <operator>(</operator><name><name>mEdgeDragsInProgress</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>&amp;</operator> <name>edge</name><operator>)</operator> <operator>==</operator> <name>edge</name>
                <operator>||</operator> <operator>(</operator><name>absDelta</name> <operator>&lt;=</operator> <name>mTouchSlop</name> <operator>&amp;&amp;</operator> <name>absODelta</name> <operator>&lt;=</operator> <name>mTouchSlop</name><operator>)</operator></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>absDelta</name> <operator>&lt;</operator> <name>absODelta</name> <operator>*</operator> <literal type="number">0.5f</literal> <operator>&amp;&amp;</operator> <call><name><name>mCallback</name><operator>.</operator><name>onEdgeLock</name></name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>mEdgeDragsLocked</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>|=</operator> <name>edge</name></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><operator>(</operator><name><name>mEdgeDragsInProgress</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>&amp;</operator> <name>edge</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>absDelta</name> <operator>&gt;</operator> <name>mTouchSlop</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if we've crossed a reasonable touch slop for the given child view.
     * If the child cannot be dragged along the horizontal or vertical axis,
     * motion along that axis will not count toward the slop check.
     *
     * @param child Child to check
     * @param dx    Motion since initial position along X axis
     * @param dy    Motion since initial position along Y axis
     * @return true if the touch slop has been crossed
     */</comment>
    <function><specifier>private</specifier> <type><name>boolean</name></type> <name>checkTouchSlop</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dx</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dy</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>child</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>checkHorizontal</name> <init>= <expr><call><name><name>mCallback</name><operator>.</operator><name>getViewHorizontalDragRange</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>checkVertical</name> <init>= <expr><call><name><name>mCallback</name><operator>.</operator><name>getViewVerticalDragRange</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>checkHorizontal</name> <operator>&amp;&amp;</operator> <name>checkVertical</name></expr>)</condition><then> <block>{
            <return>return <expr><name>dx</name> <operator>*</operator> <name>dx</name> <operator>+</operator> <name>dy</name> <operator>*</operator> <name>dy</name> <operator>&gt;</operator> <name>mTouchSlop</name> <operator>*</operator> <name>mTouchSlop</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>checkHorizontal</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>mTouchSlop</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>checkVertical</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>dy</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>mTouchSlop</name></expr>;</return>
        }</block></then></if></elseif></if>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if any pointer tracked in the current gesture has crossed the
     * required slop threshold.
     * &lt;p&gt;
     * This depends on internal state populated by
     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or
     * {@link #processTouchEvent(android.view.MotionEvent)}. You should only
     * rely on the results of this method after all currently available touch
     * data has been provided to one of these two methods.
     * &lt;/p&gt;
     *
     * @param directions Combination of direction flags, see
     *                   {@link #DIRECTION_HORIZONTAL}, {@link #DIRECTION_VERTICAL},
     *                   {@link #DIRECTION_ALL}
     * @return true if the slop threshold has been crossed, false otherwise
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>checkTouchSlop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>directions</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name> <init>= <expr><name><name>mInitialMotionX</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name>checkTouchSlop</name><argument_list>(<argument><expr><name>directions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if the specified pointer tracked in the current gesture has crossed
     * the required slop threshold.
     * &lt;p&gt;
     * This depends on internal state populated by
     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or
     * {@link #processTouchEvent(android.view.MotionEvent)}. You should only
     * rely on the results of this method after all currently available touch
     * data has been provided to one of these two methods.
     * &lt;/p&gt;
     *
     * @param directions Combination of direction flags, see
     *                   {@link #DIRECTION_HORIZONTAL}, {@link #DIRECTION_VERTICAL},
     *                   {@link #DIRECTION_ALL}
     * @param pointerId  ID of the pointer to slop check as specified by
     *                   MotionEvent
     * @return true if the slop threshold has been crossed, false otherwise
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>checkTouchSlop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>directions</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><operator>!</operator><call><name>isPointerDown</name><argument_list>(<argument><expr><name>pointerId</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>checkHorizontal</name> <init>= <expr><operator>(</operator><name>directions</name> <operator>&amp;</operator> <name>DIRECTION_HORIZONTAL</name><operator>)</operator> <operator>==</operator> <name>DIRECTION_HORIZONTAL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>checkVertical</name> <init>= <expr><operator>(</operator><name>directions</name> <operator>&amp;</operator> <name>DIRECTION_VERTICAL</name><operator>)</operator> <operator>==</operator> <name>DIRECTION_VERTICAL</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>dx</name> <init>= <expr><name><name>mLastMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>-</operator> <name><name>mInitialMotionX</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>dy</name> <init>= <expr><name><name>mLastMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>-</operator> <name><name>mInitialMotionY</name><index>[<expr><name>pointerId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>checkHorizontal</name> <operator>&amp;&amp;</operator> <name>checkVertical</name></expr>)</condition><then> <block>{
            <return>return <expr><name>dx</name> <operator>*</operator> <name>dx</name> <operator>+</operator> <name>dy</name> <operator>*</operator> <name>dy</name> <operator>&gt;</operator> <name>mTouchSlop</name> <operator>*</operator> <name>mTouchSlop</name></expr>;</return>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>checkHorizontal</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>mTouchSlop</name></expr>;</return>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>checkVertical</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name><name>Math</name><operator>.</operator><name>abs</name></name><argument_list>(<argument><expr><name>dy</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>mTouchSlop</name></expr>;</return>
        }</block></then></if></elseif></if>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if any of the edges specified were initially touched in the
     * currently active gesture. If there is no currently active gesture this
     * method will return false.
     *
     * @param edges Edges to check for an initial edge touch. See
     *              {@link #EDGE_LEFT}, {@link #EDGE_TOP}, {@link #EDGE_RIGHT},
     *              {@link #EDGE_BOTTOM} and {@link #EDGE_ALL}
     * @return true if any of the edges specified were initially touched in the
     * current gesture
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isEdgeTouched</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>edges</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>count</name> <init>= <expr><name><name>mInitialEdgeTouched</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <if>if <condition>(<expr><call><name>isEdgeTouched</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if any of the edges specified were initially touched by the pointer
     * with the specified ID. If there is no currently active gesture or if
     * there is no pointer with the given ID currently down this method will
     * return false.
     *
     * @param edges Edges to check for an initial edge touch. See
     *              {@link #EDGE_LEFT}, {@link #EDGE_TOP}, {@link #EDGE_RIGHT},
     *              {@link #EDGE_BOTTOM} and {@link #EDGE_ALL}
     * @return true if any of the edges specified were initially touched in the
     * current gesture
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isEdgeTouched</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>edges</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointerId</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isPointerDown</name><argument_list>(<argument><expr><name>pointerId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mInitialEdgeTouched</name><index>[<expr><name>pointerId</name></expr>]</index></name> <operator>&amp;</operator> <name>edges</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>releaseViewForPointerUp</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>mVelocityTracker</name><operator>.</operator><name>computeCurrentVelocity</name></name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name>mMaxVelocity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>xvel</name> <init>= <expr><call><name>clampMag</name><argument_list>(
                <argument><expr><call><name><name>VelocityTrackerCompat</name><operator>.</operator><name>getXVelocity</name></name><argument_list>(<argument><expr><name>mVelocityTracker</name></expr></argument>, <argument><expr><name>mActivePointerId</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>mMinVelocity</name></expr></argument>, <argument><expr><name>mMaxVelocity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>float</name></type> <name>yvel</name> <init>= <expr><call><name>clampMag</name><argument_list>(
                <argument><expr><call><name><name>VelocityTrackerCompat</name><operator>.</operator><name>getYVelocity</name></name><argument_list>(<argument><expr><name>mVelocityTracker</name></expr></argument>, <argument><expr><name>mActivePointerId</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>mMinVelocity</name></expr></argument>, <argument><expr><name>mMaxVelocity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>dispatchViewReleased</name><argument_list>(<argument><expr><name>xvel</name></expr></argument>, <argument><expr><name>yvel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><specifier>private</specifier> <type><name>void</name></type> <name>dragTo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dy</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>clampedX</name> <init>= <expr><name>left</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>clampedY</name> <init>= <expr><name>top</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>oldLeft</name> <init>= <expr><call><name><name>mCapturedView</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>oldTop</name> <init>= <expr><call><name><name>mCapturedView</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>dx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>clampedX</name> <operator>=</operator> <call><name><name>mCallback</name><operator>.</operator><name>clampViewPositionHorizontal</name></name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mCapturedView</name><operator>.</operator><name>offsetLeftAndRight</name></name><argument_list>(<argument><expr><name>clampedX</name> <operator>-</operator> <name>oldLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>dy</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>clampedY</name> <operator>=</operator> <call><name><name>mCallback</name><operator>.</operator><name>clampViewPositionVertical</name></name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mCapturedView</name><operator>.</operator><name>offsetTopAndBottom</name></name><argument_list>(<argument><expr><name>clampedY</name> <operator>-</operator> <name>oldTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>dx</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>dy</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>clampedDx</name> <init>= <expr><name>clampedX</name> <operator>-</operator> <name>oldLeft</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>clampedDy</name> <init>= <expr><name>clampedY</name> <operator>-</operator> <name>oldTop</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>mCallback</name>
                    <operator>.</operator><name>onViewPositionChanged</name></name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>clampedX</name></expr></argument>, <argument><expr><name>clampedY</name></expr></argument>, <argument><expr><name>clampedDx</name></expr></argument>, <argument><expr><name>clampedDy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Determine if the currently captured view is under the given point in the
     * parent view's coordinate system. If there is no captured view this method
     * will return false.
     *
     * @param x X position to test in the parent's coordinate system
     * @param y Y position to test in the parent's coordinate system
     * @return true if the captured view is under the given point, false
     * otherwise
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isCapturedViewUnder</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{
        <return>return <expr><call><name>isViewUnder</name><argument_list>(<argument><expr><name>mCapturedView</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Determine if the supplied view is under the given point in the parent
     * view's coordinate system.
     *
     * @param view Child view of the parent to hit test
     * @param x    X position to test in the parent's coordinate system
     * @param y    Y position to test in the parent's coordinate system
     * @return true if the supplied view is under the given point, false
     * otherwise
     */</comment>
    <function><specifier>public</specifier> <type><name>boolean</name></type> <name>isViewUnder</name><parameter_list>(<parameter><decl><type><name>View</name></type> <name>view</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>view</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block>{
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>x</name> <operator>&gt;=</operator> <call><name><name>view</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <call><name><name>view</name><operator>.</operator><name>getRight</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>y</name> <operator>&gt;=</operator> <call><name><name>view</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call>
                <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <call><name><name>view</name><operator>.</operator><name>getBottom</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Find the topmost child under the given point within the parent view's
     * coordinate system. The child order is determined using
     * {@link me.imid.swipebacklayout.lib.ViewDragHelper.Callback#getOrderedChildIndex(int)}
     * .
     *
     * @param x X position to test in the parent's coordinate system
     * @param y Y position to test in the parent's coordinate system
     * @return The topmost child view under (x, y) or null if none found.
     */</comment>
    <function><specifier>public</specifier> <type><name>View</name></type> <name>findTopChildUnder</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>childCount</name> <init>= <expr><call><name><name>mParentView</name><operator>.</operator><name>getChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>childCount</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>View</name></type> <name>child</name> <init>= <expr><call><name><name>mParentView</name><operator>.</operator><name>getChildAt</name></name><argument_list>(<argument><expr><call><name><name>mCallback</name><operator>.</operator><name>getOrderedChildIndex</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>x</name> <operator>&gt;=</operator> <call><name><name>child</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <call><name><name>child</name><operator>.</operator><name>getRight</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>y</name> <operator>&gt;=</operator> <call><name><name>child</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call>
                    <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <call><name><name>child</name><operator>.</operator><name>getBottom</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>child</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr><literal type="null">null</literal></expr>;</return>
    }</block></function>

    <function><specifier>private</specifier> <type><name>int</name></type> <name>getEdgeTouched</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <call><name><name>mParentView</name><operator>.</operator><name>getLeft</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>mEdgeSize</name></expr>)</condition><then>
            <block type="pseudo"><expr_stmt><expr><name>result</name> <operator>=</operator> <name>EDGE_LEFT</name></expr>;</expr_stmt></block></then></if>
        <if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <call><name><name>mParentView</name><operator>.</operator><name>getTop</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>mEdgeSize</name></expr>)</condition><then>
            <block type="pseudo"><expr_stmt><expr><name>result</name> <operator>=</operator> <name>EDGE_TOP</name></expr>;</expr_stmt></block></then></if>
        <if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <call><name><name>mParentView</name><operator>.</operator><name>getRight</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>mEdgeSize</name></expr>)</condition><then>
            <block type="pseudo"><expr_stmt><expr><name>result</name> <operator>=</operator> <name>EDGE_RIGHT</name></expr>;</expr_stmt></block></then></if>
        <if>if <condition>(<expr><name>y</name> <operator>&gt;</operator> <call><name><name>mParentView</name><operator>.</operator><name>getBottom</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>mEdgeSize</name></expr>)</condition><then>
            <block type="pseudo"><expr_stmt><expr><name>result</name> <operator>=</operator> <name>EDGE_BOTTOM</name></expr>;</expr_stmt></block></then></if>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>
}</block></class>
</unit>
