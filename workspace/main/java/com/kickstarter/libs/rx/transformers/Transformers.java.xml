<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="0.9.5" language="Java" filename="D:\AndroidAnalysis\Instrumentation-apps\kickstarter\app\src\main\java\com\kickstarter\libs\rx\transformers\Transformers.java"><package>package <name><name>com</name><operator>.</operator><name>kickstarter</name><operator>.</operator><name>libs</name><operator>.</operator><name>rx</name><operator>.</operator><name>transformers</name></name>;</package>

<import>import <name><name>com</name><operator>.</operator><name>kickstarter</name><operator>.</operator><name>services</name><operator>.</operator><name>ApiException</name></name>;</import>
<import>import <name><name>com</name><operator>.</operator><name>kickstarter</name><operator>.</operator><name>services</name><operator>.</operator><name>apiresponses</name><operator>.</operator><name>ErrorEnvelope</name></name>;</import>

<import>import <name><name>androidx</name><operator>.</operator><name>annotation</name><operator>.</operator><name>NonNull</name></name>;</import>
<import>import <name><name>rx</name><operator>.</operator><name>Observable</name></name>;</import>
<import>import <name><name>rx</name><operator>.</operator><name>functions</name><operator>.</operator><name>Action1</name></name>;</import>
<import>import <name><name>rx</name><operator>.</operator><name>subjects</name><operator>.</operator><name>PublishSubject</name></name>;</import>

<class><specifier>public</specifier> <specifier>final</specifier> class <name>Transformers</name> <block>{
  <constructor><specifier>private</specifier> <name>Transformers</name><parameter_list>()</parameter_list> <block>{}</block></constructor>

  <comment type="block" format="javadoc">/**
   * Transforms `null` values emitted from an observable into `theDefault`.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></annotation> <type><name><name>CoalesceTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>coalesce</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name>T</name></type> <name>theDefault</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>CoalesceTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>theDefault</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Emits when a materialized stream is completed.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></annotation> <type><name><name>CompletedTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>completed</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>CompletedTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Emits when an error is thrown in a materialized stream.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></annotation> <type><name><name>ErrorsTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>errors</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>ErrorsTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Prevents an observable from erroring by chaining `onErrorResumeNext`.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>NeverErrorTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>neverError</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>NeverErrorTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Prevents an observable from erroring on any {@link ApiException} exceptions.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>NeverApiErrorTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>neverApiError</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>NeverApiErrorTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Prevents an observable from erroring on any {@link ApiException} exceptions,
   * and any errors that do occur will be piped into the supplied
   * errors publish subject. `null` values will never be sent to
   * the publish subject.
   *
   * @deprecated Use {@link Observable#materialize()} instead.
   */</comment>
  <function><annotation>@<name>Deprecated</name></annotation>
  <specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>NeverApiErrorTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>pipeApiErrorsTo</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name><name>PublishSubject</name><argument_list type="generic">&lt;<argument><name>ErrorEnvelope</name></argument>&gt;</argument_list></name></type> <name>errorSubject</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>NeverApiErrorTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>errorSubject</name><operator>::</operator><name>onNext</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Prevents an observable from erroring on any {@link ApiException} exceptions,
   * and any errors that do occur will be piped into the supplied
   * errors actions. `null` values will never be sent to the action.
   *
   * @deprecated Use {@link Observable#materialize()} instead.
   */</comment>
  <function><annotation>@<name>Deprecated</name></annotation>
  <specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>NeverApiErrorTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>pipeApiErrorsTo</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name><name>Action1</name><argument_list type="generic">&lt;<argument><name>ErrorEnvelope</name></argument>&gt;</argument_list></name></type> <name>errorAction</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>NeverApiErrorTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>errorAction</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Emits the latest value of the source observable whenever the `when`
   * observable emits.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>S</name></parameter>, <parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>TakeWhenTransformer</name><argument_list type="generic">&lt;<argument><name>S</name></argument>, <argument><name>T</name></argument>&gt;</argument_list></name></type> <name>takeWhen</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name><name>Observable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>when</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>TakeWhenTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Emits the latest value of the source `when` observable whenever the
   * `when` observable emits.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>S</name></parameter>, <parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>TakePairWhenTransformer</name><argument_list type="generic">&lt;<argument><name>S</name></argument>, <argument><name>T</name></argument>&gt;</argument_list></name></type> <name>takePairWhen</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name><name>Observable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>when</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>TakePairWhenTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Zips two observables up into an observable of pairs.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>S</name></parameter>, <parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>ZipPairTransformer</name><argument_list type="generic">&lt;<argument><name>S</name></argument>, <argument><name>T</name></argument>&gt;</argument_list></name></type> <name>zipPair</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name><name>Observable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>second</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>ZipPairTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>second</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Emits the latest values from two observables whenever either emits.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <parameter_list type="generic">&lt;<parameter><name>S</name></parameter>, <parameter><name>T</name></parameter>&gt;</parameter_list> <type><name><name>CombineLatestPairTransformer</name><argument_list type="generic">&lt;<argument><name>S</name></argument>, <argument><name>T</name></argument>&gt;</argument_list></name></type> <name>combineLatestPair</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name><name>Observable</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>second</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>CombineLatestPairTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>second</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Waits until `until` emits one single item and then switches context to the source. This
   * can be useful to delay work until a user logs in:
   *
   * ```
   * somethingThatRequiresAuth
   *   .compose(waitUntil(currentUser.loggedInUser()))
   *   .subscribe(show)
   * ```
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></annotation> <type><name><name>WaitUntilTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>, <argument><name>R</name></argument>&gt;</argument_list></name></type> <name>waitUntil</name><parameter_list>(<parameter><decl><type><specifier>final</specifier> <annotation>@<name>NonNull</name></annotation> <name><name>Observable</name><argument_list type="generic">&lt;<argument><name>R</name></argument>&gt;</argument_list></name></type> <name>until</name></decl></parameter>)</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>WaitUntilTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>(<argument><expr><name>until</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Converts an observable of any type into an observable of `null`s. This is useful for forcing
   * Java's type system into knowing we have a stream of `Void`. Simply doing `.map(__ -&gt; null)`
   * is not enough since Java doesn't know if that is a `null` String, Integer, Void, etc.
   *
   * This transformer allows the following pattern:
   *
   * ```
   * myObservable
   *   .compose(takeWhen(click))
   *   .compose(ignoreValues())
   *   .subscribe(subject::onNext)
   * ```
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>S</name></argument>&gt;</argument_list></name></annotation> <type><name><name>IgnoreValuesTransformer</name><argument_list type="generic">&lt;<argument><name>S</name></argument>&gt;</argument_list></name></type> <name>ignoreValues</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>IgnoreValuesTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Emits the number of times the source has emitted for every emission of the source. The
   * first emitted value will be `1`.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></annotation> <type><name><name>IncrementalCountTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>incrementalCount</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>IncrementalCountTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * Emits an observable of values from a materialized stream.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></annotation> <type><name><name>ValuesTransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>values</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>ValuesTransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block" format="javadoc">/**
   * If called on the main thread, schedule the work immediately. Otherwise delay execution of the work by adding it
   * to a message queue, where it will be executed on the main thread.
   *
   * This is particularly useful for RecyclerViews; if subscriptions in these views are delayed for a frame, then
   * the view temporarily shows recycled content and frame rate stutters. To address that, we can use `observeForUI()`
   * to execute the work immediately rather than wait for a frame.
   */</comment>
  <function><specifier>public</specifier> <specifier>static</specifier> <annotation>@<name><name>NonNull</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></annotation> <type><name><name>ObserveForUITransformer</name><argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>observeForUI</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><operator>new</operator> <call><name><name>ObserveForUITransformer</name><argument_list type="generic">&lt;&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>
}</block></class>
</unit>
