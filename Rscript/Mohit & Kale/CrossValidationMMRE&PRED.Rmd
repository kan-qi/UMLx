---
title: "Multiple Regression, Cross Validation MMRE & PRED"
author: "Mohit, Songyh and AtharvaKale"
date: "3/6/2018"
output:
  pdf_document: 
    keep_tex: yes
  html_document: default
  word_document: default
---


Loading data form the csv file

```{r}
data <- read.csv("/Users/mohit/Development/My Scripts/modelsEvaluation.csv",stringsAsFactors= T)
summary(data)
```

## Preprocessing the data
Replacing all the NaN with the mean value. 

```{r}
data$NT = ifelse(is.na(data$NT), ave(data$NT, FUN = function(x) mean(x, na.rm = TRUE)),data$NT)
data$INT_ALY = ifelse(is.na(data$INT_ALY), ave(data$INT_ALY, FUN = function(x) mean(x, na.rm = TRUE)),data$INT_ALY)
data$INT = ifelse(is.na(data$INT), ave(data$INT, FUN = function(x) mean(x, na.rm = TRUE)),data$INT)
data$DM = ifelse(is.na(data$DM), ave(data$DM, FUN = function(x) mean(x, na.rm = TRUE)),data$DM)
data$CTRL = ifelse(is.na(data$CTRL), ave(data$CTRL, FUN = function(x) mean(x, na.rm = TRUE)),data$CTRL)
data$EXTCLL = ifelse(is.na(data$EXTCLL), ave(data$EXTCLL, FUN = function(x) mean(x, na.rm = TRUE)),data$EXTCLL)
data$EXTIVK = ifelse(is.na(data$EXTIVK), ave(data$EXTIVK, FUN = function(x) mean(x, na.rm = TRUE)),data$EXTIVK)
```

## Preparing the independent variables
1. Removing all the variables with zero value for all the observations. 
2. Facorizing the type variable
3. Calculating the corelation between all the independent and dependent variables.
4. Choosing all the variables with highest corelation values. 

```{r}
x <-data[,7:45];
x$Type = factor(x$Type, levels = c('Web App', 'Mobile App', 'Mobile&Web App'),labels = c(1,2,3))
x$ILF<-NULL
x$EIF<-NULL
x$DET<-NULL
x$EF_ALY<-NULL
x$TCF_ALY<-NULL
x$Type[5] = 1
x$Type[7] = 1
x$Type[20] = 3
x$Type = as.numeric(x$Type)

y =data$Effort
summary(x)
```

## Correlation 
Calculating the correlation and choosing the independent variables with correlation higher than 0.6 with the dependent variable (Effort).

``` {r}
corr <- cor(x,y)
plot(corr,xlim=c(0, 36))
text(1:35,corr,row.names(corr),cex=0.4, pos=4, col="blue")
abline(h=0.6,col="red")
```

Looking at the graph, following are the most correlated independent variables:  
1. KSLOC  
2. UEUCW_ALY  
3. UEXUCW_ALY  
4. UDUCW_ALY  
5. Effort_Norm_UCP  
6. Path_Num  
7. DUCP_ALY  
8. EXUCP_ALY  
9. EUCP_ALY  
10. UseCase_Num  
11. Diagram_Num  
12. INT_ALY  
13. DM_ALY  
14. CTRL_ALY  
15. NT_ALY  
16. NWT_DE_ALY  
17. NWT_ALY  
  

## Model Fitting

Using all the above variables except UseCase_NUM and Diagram_Num for fitting the model.  

```{r}
independentVar <- data.frame(x$KSLOC,x$UEUCW_ALY,x$UEXUCW_ALY,x$UDUCW_ALY,x$Effort_Norm_UCP,x$Path_Num,x$DUCP_ALY,x$EXUCP_ALY,x$EUCP_ALY,x$INT_ALY,x$DM_ALY,x$CTRL_ALY,x$NWT_DE_ALY,x$NWT_ALY)

names(independentVar)<- c("KSLOC","UEUCW_ALY","UEXUCW_ALY","UDUCW_ALY","Effort_Norm_UCP","Path_Num","DUCP_ALY","EXUCP_ALY","EUCP_ALY","INT_ALY","DM_ALY","CTRL_ALY","NWT_DE_ALY","NWT_ALY")

#library(caret)
#set.seed(30)
#model <- train(y~.,data=independentVar,method="lm",trControl = trainControl(method = "cv", number=2,verboseIter = TRUE))

fit <- lm(y~.,data=independentVar)
summary(fit)
```




---
title: "CrossValidationMMRE&PRED"
author: "Songyh & AtharvaKale"
date: "3/6/2018"
output:
  html_document: default
  pdf_document: 
    keep_tex: yes
  word_document: default
---


```{r}
raw_data <- read.csv(file = "/Users/mohit/Development/My Scripts/modelsEvaluation.csv", stringsAsFactors = F)
```


```{r}
# if there is some missing value
sort(sapply(raw_data, function(x) {
            sum(is.na(x))
}), decreasing  = T)
```

```{r}
which(sapply(raw_data, function(x){sum(x == 'undefined') > 0}))
```

```{r}
raw_data[which(raw_data$INT == 'undefined'),'INT'] = 0
raw_data[which(raw_data$DM == 'undefined'),'DM'] = 0
raw_data[which(raw_data$CTRL == 'undefined'),'CTRL'] = 0
raw_data[which(raw_data$EXTIVK == 'undefined'),'EXTIVK'] = 0
raw_data[which(raw_data$EXTCLL == 'undefined'),'EXTCLL'] = 0
raw_data[which(raw_data$NT == 'undefined'),'NT'] = 0
raw_data[which(raw_data$NT == 'NaN'),'NT'] = 0
```


```{r}
# check type of each column
sapply(raw_data, mode)
```


```{r}
# transfer type of columns
raw_data <- transform(raw_data, INT = as.numeric(INT),
          DM = as.numeric(DM),
          CTRL = as.numeric(CTRL),
          EXTIVK = as.numeric(EXTIVK),
          EXTCLL = as.numeric(EXTCLL),
          NT = as.numeric(NT),
          Type = as.factor(Type))
```

```{r}
# check again
sapply(raw_data, mode)
```

```{r}
# X_data <- subset(raw_data, select = -c(NUM, PROJ, Effort, Effort_ALY, Effort_Norm, Norm_Factor))
X_data = subset(raw_data, select = c("EF","TCF","Type","KSLOC","Normalized_UC_Effort",
                       "UAW","Average_UC","RET","EXTIVK"))
Y_data <- raw_data[,"Effort"]
```


```{r}
X_data[which(X_data$Type == 'Mobile App' | X_data$Type == 'Mobile Game'), 'type'] = 0
X_data[which(X_data$Type == 'Web App' | X_data$Type == 'web App'), 'type'] = 1
X_data[which(X_data$Type == 'Mobile&Web App'), 'type'] = 2
```

```{r}
X_data = subset(X_data, select = -c(Type))
```

```{r}
# scale numberic features
myscale = function(x) sqrt(sum((x - mean(x)) ^ 2) / length(x))
sx = as.matrix(scale(X_data, scale = apply(X_data, 2, myscale)))
sy = as.vector(scale(Y_data, scale = myscale(Y_data)))
```


```{r}
# X_data <- model.matrix(~., X_data)
```


```{r}
library(glmnet)
```


```{r}
lasso_lm <- glmnet(x = as.matrix(X_data), y = as.vector(Y_data), alpha = 1, standardize = F)
```


```{r}
lasso_lm$lambda
```


```{r}
plot(lasso_lm)
```

```{r}
#library(plotmo) # for plot_glmnet
```

```{r}
# for 10 biggest final features
#plot_glmnet(lasso_lm)                             # default colors
#plot_glmnet(lasso_lm, label=10)
```


```{r}
Lasso_range = function(x, y, k){
  # inputs:
      # x, independent variables
      # y: dependent varaibles
      # k: the length of sequence
  # output:
      # seq: a sequence of lambdaa from high to low
  
  
  # define my own scale function to simulate that in glmnet
  # myscale = function(x) sqrt(sum((x - mean(x)) ^ 2) / length(x))
  # 
  # # normalize x and y
  # sx = as.matrix(scale(x, scale = apply(x, 2, myscale)))
  # sy = as.vector(scale(y, scale = myscale(y)))
  
  sx = as.matrix(x)
  sy = as.vector(y)
  
  max_lambda = max(abs(colSums(sx * sy))) / dim(x)[1]
  # The default depends on the sample size nobs relative to the number of variables nvars. 
  # If nobs > nvars, the default is 0.0001, close to zero. 
  
  # If nobs < nvars, the default is 0.01. 
  # A very small value of lambda.min.ratio will lead to a saturated fit in the nobs < nvars case. 
  ratio = 0
  if(dim(sx)[1] > dim(sx)[2]){
    ratio = 0.0001
  }else{
    ratio = 0.01
  }
  
  min_lambda = max_lambda * ratio
  
  log_seq = seq(from  = log(min_lambda), to = log(max_lambda), length.out = k)
  seq = sort(exp(log_seq), decreasing = T)
  return(seq)
}
```

```{r}
Lasso_range(sx, sy, 100)
```

```{r}
set.seed(2)
lambda_list <- Lasso_range(sx,sy,100)
percent = 50
cvfit = cv.glmnet(data.matrix(sx),sy,
                  standardize = F, type.measure = 'mse', nfolds = 5, alpha = 1)
# # 5 fold cross validation
 k <- 5
# 
# function to calculate MMRE
calcMMRE <- function(testData,pred){
  mmre <- abs(testData - pred)/testData
  mean_value <- mean(mmre)
  mean_value
}
# # function to calculate PRED
calcPRED <- function(testData,pred,percent){
  value <- abs(testData - pred)/testData
  percent_value <- percent/100
  pred_value <- value <= percent_value
  mean(pred_value)
}
# 
 folds <- cut(seq(1,nrow(sx)),breaks=k,labels=FALSE)
 mean_mmre <- vector("list",k)
 mean_pred <- vector("list",k)
 overall_mean_mmre <- vector("list",100)
 overall_mean_pred <- vector("list",100)
 for(iterator in seq(1,100)){
   for(i in 1:k){
     testIndexes <- which(folds==i,arr.ind=TRUE)
     testData <- sy[testIndexes]
     trainData <- sx[-testIndexes,]
     pred <- predict(cvfit,newx=data.matrix(sx),s=lambda_list[[iterator]])
     #print(paste("Iterator",iterator, i),sep=" ")
     mean_mmre[[i]] <- calcMMRE(testData,pred[testIndexes])
     mean_pred[[i]] <- calcPRED(testData,pred[testIndexes],percent)
 }
 overall_mean_mmre[[iterator]] <- mean(as.numeric(mean_mmre))
 overall_mean_pred[[iterator]] <- mean(as.numeric(mean_pred))
 #print(overall_mean_mmre[[iterator]])
 #print(overall_mean_pred[[iterator]])
 }
```

```{r}
plot(log(lambda_list),overall_mean_mmre,xlab="log(Lambda)",ylab="MMRE")
```

```{r}
plot(log(lambda_list),overall_mean_pred,xlab="log(Lambda)",ylab = "PRED")
```
```{r}
plot(cvfit)
```

