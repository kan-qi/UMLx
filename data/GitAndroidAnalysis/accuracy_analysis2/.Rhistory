print(filePath)
print("file doesn't exist")
if(is.null(cachedTransactionFiles[[filePath]])){
cachedTransactionFiles[[filePath]] <<- data.frame(TL = numeric(),
TD = numeric(),
DETs = numeric())
}
cachedTransactionFiles[[filePath]]
}
else {
#filePath = "D:\\AndroidAnalysis\\GatorAnalysisResults\\ClusteringAnalysis-20190418T224936Z-006\\ClusteringAnalysis\\Timber_S1W1L1\\filteredTransactionEvaluation.csv"
fileData = NULL
tryCatch(fileData <- read.csv(filePath),  error=function(e) fileData = NULL)
if(nrow(fileData) == 0 || is.null(fileData)){
fileData <- data.frame(TL = numeric(),
TD = numeric(),
DETs = numeric())
}
else{
if(nrow(fileData) == 1){
fileData = apply(subset(fileData, select = c("TL", "TD", "DETs")), 2, function(x) as.numeric(x))
fileData = t(fileData)
}
else{
fileData = apply(subset(fileData, select = c("TL", "TD", "DETs")), 2, function(x) as.numeric(x))
}
fileData <- as.data.frame(fileData)
}
fileData <- na.omit(fileData)
cachedTransactionFiles[[filePath]] <<- fileData
fileData
}
}
loadTransactionData <- function(modelData){
# load the transaction data from the transaction file paths column of model data
#
# Args:
#   modelData: the model data with various fields to describe a project and a colum to reference the associated transaction data
#
# Returns:
#   the transaction data for each project
modelData$transaction_file <- as.character(modelData$transaction_file)
effort <- subset(modelData, select=c("Effort"))
projects <- rownames(modelData)
rownames(effort) <- projects
transactionFileList <- subset(modelData, select=c("transaction_file"))
rownames(transactionFileList) <- projects
numOfTrans <- 0
transactionFiles <- list()
for (project in projects) {
filePath <- transactionFileList[project, "transaction_file"]
#print(filePath)
fileData <- readTransactionData(filePath)
transactionFiles[[project]] <- fileData
numOfTrans = numOfTrans + nrow(fileData)
}
print(numOfTrans)
combined <- combineData(transactionFiles)
transactionData = list(combined=combined, transactionFiles = transactionFiles, effort = effort, projects=projects)
}
generateRegressionData <- function(projects, cutPoints, effortData, transactionFiles){
# classified the transactions into different levels of complexity for regression analysis
#
# Args:
#   projects: the projects
#   cutPoints: the cut points that define the classification of the transactions.
#   effortData: the effort for the projects
#   transactionFiles: the tranaction records for the projects
#
# Returns:
#   the numbers of transactions for different complexity levels and project effort.
nParams =  nrow(cutPoints)
nBins =   ncol(cutPoints)-1
levels = genColNames(nParams, nBins)
regressionData <- matrix(nrow = length(projects), ncol = length(levels) + 1)
rownames(regressionData) <- projects
colnames(regressionData) <- c(levels, "Effort")
for (project in projects) {
fileData <- transactionFiles[[project]]
classifiedData <- classify(fileData, cutPoints)
regressionData[project, ] <- c(classifiedData, effortData[project, "Effort"])
}
regressionData <- na.omit(regressionData)
regressionData <- as.data.frame(regressionData)
}
performSearch <- function(n, dataset, parameters = c("TL", "TD", "DETs"), k = 5) {
# Performs search for the optimal number of bins and weights to apply to each
# bin through linear regression.
#
# Args:
#   n: Specifies up to how many bins per parameter to search.
#   folder: Folder containg all the transaction analytics data to analyze.
#   effortData: a data frame containing effort data corresponding to each of
#               the files contained in the folder argument. Rows must be named
#               the same as the filename and effort column should be named "Effort".
#   parameters: A vector of which parameters to analyze. Ex. "TL", "TD", "DETs". When the parameters is an empty array, just apply linear regression on number of transactions.
#   k: How many folds to use for k-fold cross validation.
#
# Returns:
#   A list in which the ith index gives the results of the search for i bins.
#n = 6
#dataset = modelData
#parameters = c("TL", "TD", "DETs")
#k = 5
#dataset <- modelData
#cachedTransactionFiles <- list()
#load transaction data from the datasheet
transactionData <- loadTransactionData(dataset)
#distParams = list();
#distParams[['TL']] = list(shape=6.543586, rate=1.160249);
#distParams[['TD']] = list(shape=3.6492150, rate=0.6985361);
#distParams[['DETs']] = list(shape=1.6647412, rate=0.1691911);
#Ks parameteric test
#distParams = list();
#print(combinedData[,])
#hist(combinedData[combinedData$TL < 20 & combinedData$TL > 2,"TL"])
#hist(combinedData[combinedData$TD < 100, "TD"])
#hist(combinedData[combinedData$DETs < 10, "DETs"])
#n <- 5
#quantiles <- seq(1/n, 1 - (1/n), 1/n)
#print(classIntervals(combinedData[combinedData$DETs < 30, "DETs"], 6, style = 'quantile'))
#print(classIntervals(combinedData[,"TL"], 4)$brks)
#print(quantize(combinedData[,"TL"], quantiles))
#distParams[['TL']] = (combinedData[combinedData$TL < 20 & combinedData$TL > 2,"TL"]);
#distParams[['TD']] = distFit(combinedData[combinedData$TD < 1000, "TD"]);
#distParams[['DETs']] = distFit(combinedData[combinedData$DETs < 10, "DETs"]);
#paramAvg <- if (length(parameters) == 1) mean(combinedData[, parameters]) else colMeans(combinedData[, parameters])
#paramSD <- if (length(parameters) == 1) sd(combinedData[, parameters]) else apply(combinedData[, parameters], 2, sd)
if(length(parameters) == 0){
n = 1
}
searchResults <- list()
for (i in seq(1,n)) {
cutPoints <- matrix(NA, nrow = length(parameters), ncol = i + 1)
rownames(cutPoints) <- parameters
for (p in parameters) {
cutPoints[p, ] <- discretize(transactionData$combined[,p], i)
}
#generate classified regression data
regressionData <- generateRegressionData(transactionData$projects, cutPoints, transactionData$effort, transactionData$transactionFiles)
`%ni%` <- Negate(`%in%`)
paramVals <- bayesfit(regressionData, 10000, 500)
bayesianModel = list()
bayesianModel$weights = subset(paramVals, select = colnames(regressionData) %ni% c("Effort", "sd"))
bayesianModel$effortAdj = paramVals[,"effortAdj"]
bayesianModel$sd = paramVals[,"sd"]
bayesianModel$cuts <- cutPoints
bm_validationResults <- crossValidate(regressionData, k, function(trainData) bayesfit(trainData, 1000, 500), predict.blm)
#print(bm_validationResults)
#the regression model fit
regressionModel <- lm(Effort ~ . - 1, as.data.frame(regressionData));
reg_validationResults <- crossValidate(regressionData, k,function(trainData) lm(Effort ~ . - 1, as.data.frame(trainData)), function(lm.fit, testData) predict(lm.fit, newData = testData))
#the prior model fit
priorModel <- priorFit(regressionData)
prior_validationResults <- crossValidate(regressionData, k, priorFit, function(priorModel, testData) predict(priorModel, newData = testData))
searchResults[[i]] <- list(
bayesModel = bayesianModel,
bayesModelAccuracyMeasure = bm_validationResults,
priorModel = priorModel,
priorModelAccuracyMeasure = prior_validationResults,
regressionModel = regressionModel,
regressionModelAccuracyMeasure = reg_validationResults,
regressionData = regressionData
)
}
searchResults
}
#effort <- read.csv("modelEvaluations_8_12.csv")
#rownames(effort) <- effort$Project
#SWTIresults <- performSearch(3, effort, c("TL"))
predict.swt <- function(trainedModel, testData){
# predict the effort based on a data point
#
# Args:
#   trainedModel: the trained transaction-based model
#   testData: the data point used to predict project effort
#
# Returns:
#   the estimated project effort
#trainedModelParameters <- readRDS(file="train_model_parameters.rds")
transactionData <- loadTransactionData(testData)
effortData <- transactionData$effort
combinedData <- transactionData$combined
transactionFiles = transactionData$transactionFiles
projects <- names(transactionData$transactionFiles)
#cuts = model$m$cuts
regressionData <- generateRegressionData(projects, trainedModel$cuts, effortData, transactionFiles)
predicted <- predict.blm(as.matrix(trainedModel$paramVals), newdata = regressionData)
predicted
}
fit.swt <- function(swtiii,dataset){
# the model fitting function which would be repeated called during the cross validation and bootstrapping function
#
# Args:
#   swtiii: a list of cut points, which are the hyper parameters of the transaction-based model.
#   dataset: the dataset based on which the model is fitted
#
# Returns:
#   the fitted transaction-based model
print("swtiii model training")
#swtiii <- models$tm1
#dataset <- modelData
transactionData <- loadTransactionData(dataset)
effortData <- transactionData$effort
combinedData <- transactionData$combined
transactionFiles <- transactionData$transactionFiles
projects <- names(transactionData$transactionFiles)
regressionData <- generateRegressionData(projects, swtiii$cuts, effortData, transactionFiles)
paramVals <- bayesfit(regressionData, 10000, 500)
bayesianModel = list()
bayesianModel$paramVals <- paramVals
bayesianModel$cuts <- swtiii$cuts
swtiii$cuts = NULL;
swtiii$m = bayesianModel;
swtiii
}
m_fit.tm3 <- function(swtiii,dataset){
print("swtiii model training")
#swtiii <- models$tm1
#dataset <- modelData
fit.swt(swtiii, dataset)
}
# for model testing
m_predict.tm3 <- function(swtiii, testData){
print("swtiii predict function")
predict.swt(swtiii$m, testData)
}
m_fit.tm2 <- function(swtii,dataset){
print("swtii model training")
#swtiii <- models$tm1
#dataset <- modelData
fit.swt(swtii, dataset)
}
# for model testing
m_predict.tm2 <- function(swtii, testData){
print("swtii predict function")
predict.swt(swtii$m, testData)
}
m_fit.tm1 <- function(swti,dataset){
print("swti model training")
#swtiii <- models$tm1
#dataset <- modelData
fit.swt(swti, dataset)
}
# for model testing
m_predict.tm1 <- function(swti, testData){
print("swti predict function")
predict.swt(swti$m, testData)
}
trainsaction_based_model <- function(modelData){
# initiate the transaction-based model by performing a search of optimal classification of transactions, which are defined as a set of cut points
#
# Args:
#   modelData: a held-out dataset to search for the hyperparameter
#
# Returns:
#   the list of cuts points for the individual dimensions
models = list()
#cachedTransactionFiles = list()
SWTIIIresults <- performSearch(6, modelData, c("TL", "TD", "DETs"))
#intialize the model with hyper parameters (cutpoints) decided by cross validatoin results for different ways of binning
#SWTIIIresults <- models$tm3$SWTIIIresults
accuracyMeasures <- as.data.frame(t(sapply(SWTIIIresults, function(iterResults){
iterResults$bayesModelAccuracyMeasure[c('MMRE', 'PRED25', 'MAE', "MDMRE")]
})))
accuracyRanks <- rankModels(accuracyMeasures)
#print(accuracyRanks)
#print(accuracyMeasures)
#SWTIIIModelSelector <- 3
SWTIIIModelSelector <- which.min(accuracyRanks[,'rank*'])
print(paste("swtiii: ", SWTIIIModelSelector, sep=""))
modelParams = SWTIIIresults[[SWTIIIModelSelector]][["bayesModel"]]
models$tm3 = list(
cuts = modelParams$cuts,
trainedModel = list(
weights = lapply(modelParams$weights,Bayes.sum),
effortAdj = Bayes.sum(modelParams$effortAdj),
sd = Bayes.sum(modelParams$sd)
),
SWTIIIresults = SWTIIIresults
)
SWTIIresults <- performSearch(6, modelData, c("TL", "TD"))
#SWTIIModelSelector <- 4
#SWTIIresults <- models$tm2$SWTIIresults
accuracyMeasures <- as.data.frame(t(sapply(SWTIIresults, function(iterResults){
iterResults$bayesModelAccuracyMeasure[c('MMRE', 'PRED25', 'MAE', "MDMRE")]
})))
#print(accuracyMeasures)
accuracyRanks <- rankModels(accuracyMeasures)
#print(accuracyRanks)
SWTIIModelSelector <- which.min(accuracyRanks[,'rank*'])
#print(SWTIIModelSelector)
#print(paste("swtiii: ", SWTIIIModelSelector, sep=""))
modelParams = SWTIIresults[[SWTIIModelSelector]][["bayesModel"]]
models$tm2 = list(
cuts = modelParams$cuts,
trainedModel = list(
weights = lapply(modelParams$weights,Bayes.sum),
effortAdj = Bayes.sum(modelParams$effortAdj),
sd = Bayes.sum(modelParams$sd)
),
SWTIIresults = SWTIIresults
)
#cachedTransactionFiles = list()
SWTIresults <- performSearch(6, modelData, c())
#intialize the model with hyper parameters (cutpoints) decided by cross validatoin results for different ways of binning
SWTIModelSelector <- 1
modelParams = SWTIresults[[SWTIModelSelector]][["bayesModel"]]
models$tm1 = list(
cuts = modelParams$cuts,
trainedModel = list(
weights = lapply(modelParams$weights,Bayes.sum),
effortAdj = Bayes.sum(modelParams$effortAdj),
sd = Bayes.sum(modelParams$sd)
),
SWTIresults = SWTIresults
)
models
}
trainsaction_based_model1 <- function(modelData){
# initiate the transaction-based model by performing a search of optimal classification of transactions, which are defined as a set of cut points
#
# Args:
#   modelData: a held-out dataset to search for the hyperparameter
#
# Returns:
#   the list of cuts points for the individual dimensions
models = list()
#cachedTransactionFiles = list()
SWTIresults <- performSearch(6, modelData, c())
#intialize the model with hyper parameters (cutpoints) decided by cross validatoin results for different ways of binning
SWTIModelSelector <- 1
modelParams = SWTIresults[[SWTIModelSelector]][["bayesModel"]]
models$tm1 = list(
cuts = modelParams$cuts,
trainedModel = list(
weights = lapply(modelParams$weights,Bayes.sum),
effortAdj = Bayes.sum(modelParams$effortAdj),
sd = Bayes.sum(modelParams$sd)
),
SWTIresults = SWTIresults
)
models
}
m_profile.tm1 <- function(model, dataset){
#model = trainedModels[['tm1']]
#dataset = modelData
swti = model
transactionData <- loadTransactionData(dataset)
effortData <- transactionData$effort
combinedData <- transactionData$combined
transactionFiles <- transactionData$transactionFiles
projects <- names(transactionData$transactionFiles)
regressionData1 <- generateRegressionData(projects, swti$m$cuts, effortData, transactionFiles)
regLevels1 <- colnames(regressionData1)[!(colnames(regressionData1) %in% c("Effort"))]
profileData <- matrix(nrow=nrow(dataset), ncol=length(regLevels1)+1)
profileData <- as.data.frame(profileData)
rownames(profileData) <- rownames(dataset)
swti_levels <- paste("swti_", regLevels1, sep="")
colnames(profileData) <- c(swti_levels, "SWTI")
regress1 <- as.matrix(regressionData1[,regLevels1])
rownames(regress1) <- rownames(regressionData1)
colnames(regress1) <- swti_levels
#print(regress1)
profileData[,swti_levels] <- regress1
profileData$SWTI <- calculateSize(as.matrix(swti$m$paramVals), regressionData1)
profileData
}
m_profile.tm2 <- function(model, dataset){
#model = trainedModels[["tm2"]]
#dataset = modelData
swtii = model
transactionData <- loadTransactionData(dataset)
effortData <- transactionData$effort
combinedData <- transactionData$combined
transactionFiles <- transactionData$transactionFiles
projects <- names(transactionData$transactionFiles)
regressionData2 <- generateRegressionData(projects, swtii$m$cuts, effortData, transactionFiles)
regLevels2 <- colnames(regressionData2)[!(colnames(regressionData2) %in% c("Effort"))]
profileData <- matrix(nrow=nrow(dataset), ncol=length(regLevels2)+1)
profileData <- as.data.frame(profileData)
rownames(profileData) <- rownames(dataset)
swtii_levels <- paste("swtii_", regLevels2, sep="")
colnames(profileData) <- c(swtii_levels, "SWTII")
regress2 <- as.matrix(regressionData2[,regLevels2])
rownames(regress2) <- rownames(regressionData2)
colnames(regress2) <- swtii_levels
#print(regress1)
profileData[,swtii_levels] <- regress2
profileData$SWTII <- calculateSize(as.matrix(swtii$m$paramVals), regressionData2)
profileData
}
m_profile.tm3 <- function(model, dataset){
#dataset = modelData
swtiii = model
transactionData <- loadTransactionData(dataset)
effortData <- transactionData$effort
combinedData <- transactionData$combined
transactionFiles <- transactionData$transactionFiles
projects <- names(transactionData$transactionFiles)
regressionData3 <- generateRegressionData(projects, swtiii$m$cuts, effortData, transactionFiles)
regLevels3 <- colnames(regressionData3)[!(colnames(regressionData3) %in% c("Effort"))]
profileData <- matrix(nrow=nrow(dataset), ncol=length(regLevels3)+1)
profileData <- as.data.frame(profileData)
rownames(profileData) <- rownames(dataset)
swtiii_levels <- paste("swtiii_", regLevels3, sep="")
colnames(profileData) <- c(swtiii_levels, "SWTIII")
regress3 <- as.matrix(regressionData3[,regLevels3])
rownames(regress3) <- rownames(regressionData3)
colnames(regress3) <- swtiii_levels
#print(regress1)
profileData[,swtiii_levels] <- regress3
profileData$SWTIII <- calculateSize(as.matrix(swtiii$m$paramVals), regressionData3)
profileData
}
trainsaction_based_model3 <- function(modelData){
# initiate the transaction-based model by performing a search of optimal classification of transactions, which are defined as a set of cut points
#
# Args:
#   modelData: a held-out dataset to search for the hyperparameter
#
# Returns:
#   the list of cuts points for the individual dimensions
#cachedTransactionFiles = list()
SWTIIIresults <- performSearch(6, modelData, c("TL", "TD", "DETs"))
#intialize the model with hyper parameters (cutpoints) decided by cross validatoin results for different ways of binning
#SWTIIIModelSelector <- 3
#SWTIIIresults <- models$tm3$SWTIIIresults
accuracyMeasures <- sapply(SWTIIIresults, function(iterResults){
iterResults$bayesModelAccuracyMeasure[c('PRED', 'MMRE')]
})
print(as.data.frame(t(accuracyMeasures)))
SWTIIIModelSelector <- which.max(accuracyMeasures)
#print(SWTIIIModelSelector)
modelParams = SWTIIIresults[[SWTIIIModelSelector]][["bayesModel"]]
tm3 = list(
cuts = modelParams$cuts,
trainedModel = list(
weights = lapply(modelParams$weights,Bayes.sum),
effortAdj = Bayes.sum(modelParams$effortAdj),
sd = Bayes.sum(modelParams$sd)
),
SWTIIIresults = SWTIIIresults
)
}
transaction_data_profile <- function(dataset){
transactionData <- loadTransactionData(dataset)
effortData <- transactionData$effort
combinedData <- transactionData$combined
transactionFiles <- transactionData$transactionFiles
projects <- names(transactionData$transactionFiles)
column_names <- c("Trans", "Stm", "Comp",
"TL", "TL_SE", "TD",
"TD_SE", "DETs", "DETs_SE")
profileData <- matrix(nrow=nrow(dataset), ncol=length(column_names))
profileData <- as.data.frame(profileData)
rownames(profileData) <- rownames(dataset)
colnames(profileData) <- column_names
profileData$Trans <- dataset$Tran_Num
profileData$Stm <- dataset$Stimulus_Num
profileData$Comp <- dataset$Component_Num
attr_means <- as.data.frame(t(sapply(transactionFiles, function(x){sapply(x, mean)})))
attr_sds <- as.data.frame(t(sapply(transactionFiles, function(x){sapply(x, sd)})))
profileData$TL <- attr_means$TL
profileData$TD <- attr_means$TD
profileData$DETs <- attr_means$DETs
profileData$TL_SE <- attr_sds$TL
profileData$TD_SE <- attr_sds$TD
profileData$DETs_SE <- attr_sds$DETs
profileData
}
#models1 = models
#register the model into the models list with the hyper parameters returned from  the "trainsaction_based_model" function
#transaction_models1 <- transaction_models
transaction_models <- trainsaction_based_model(modelData)
View(modelData)
View(modelData)
#profile iteration data
iterationData <- profileIterationData(transaction_models$tm3$SWTIIIresults)
print(iterationData)
iterationData1 <- profileIterationData(transaction_models$tm2$SWTIIresults)
print(iterationData1)
View(trainedModels)
View(trainedModels)
View(transaction_models)
View(transaction_models)
View(models)
View(models)
View(transaction_models)
View(transaction_models)
#profile iteration data
profileIterationData <- function(iterResults){
#profile iteration data
iterationData <- profileIterationData(transaction_models$tm3$SWTIIIresults)
print(iterationData)
#profile iteration data
iterationData <- profileIterationData(transaction_models$tm3$SWTIIIresults)
print(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
View(iterationData)
#profile iteration data
profileIterationData <- function(iterResults){
