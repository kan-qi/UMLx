#print(range[1])
for (i in 1:nrow(modelData)) {
modelDataItem <- modelData[i, ]
if(modelDataItem$KSLOC > range[1] && modelDataItem$KSLOC <= range[2]){
selectedRows <- c(selectedRows, i)
}
}
print(selectedRows)
modelData <- modelData[selectedRows,]
}
classify <- function(data, cutPoints) {
classifiedDataPoints <- classify(modelData, cutpoints)
View(sig_bs_f)
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
print(sumCoord)
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
classify <- function(data, cutPoints) {
#cutPoints = cutpoints
#print(cutPoints)
#data <- modelData
numVariables <- nrow(cutPoints)
numBins <- ncol(cutPoints) - 1
totalClassifications <- numVariables*numBins - numVariables + 1
levels <- paste("l", 1:totalClassifications, sep = "")
result <- list()
if(nrow(data) > 0){
for (i in 1:nrow(data)) {
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
combinedClass <- paste("l", sumCoord-nrow(cutPoints)+1, sep = "")
if(is.null(result[[combinedClass]])){
result[[combinedClass]] = c()
}
result[combinedClass] <- c(result[combinedClass], data$Project)
}
}
return(result)
}
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
classify <- function(data, cutPoints) {
#cutPoints = cutpoints
#print(cutPoints)
#data <- modelData
numVariables <- nrow(cutPoints)
numBins <- ncol(cutPoints) - 1
totalClassifications <- numVariables*numBins - numVariables + 1
levels <- paste("l", 1:totalClassifications, sep = "")
result <- list()
if(nrow(data) > 0){
for (i in 1:nrow(data)) {
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
combinedClass <- paste("l", sumCoord-nrow(cutPoints)+1, sep = "")
if(is.null(result[[combinedClass]])){
result[[combinedClass]] = c()
}
result[combinedClass] <- c(result[combinedClass], data$Project)
}
}
return(result)
}
#dataset <- na.omit(modelData$SLOC)
cutPoints <- as.vector(classIntervals(na.omit(dataset), 3)$brks)
cutpoints = matrix(nrow = 3, ncol = length(sloc_cut_points))
rownames(cutpoints) = c("SLOC", "Duration", "Personnel")
cutpoints["SLOC",] = sloc_cut_points
cutpoints["Duration",] = duration_cut_points
cutpoints["Personnel",] = personnel_cut_points
print(cutpoints)
classifiedDataPoints <- classify(modelData, cutpoints)
cutPoints = cutpoints
#print(cutPoints)
data <- modelData
numVariables <- nrow(cutPoints)
numBins <- ncol(cutPoints) - 1
totalClassifications <- numVariables*numBins - numVariables + 1
levels <- paste("l", 1:totalClassifications, sep = "")
result <- list()
if(nrow(data) > 0){
for (i in 1:nrow(data)) {
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
combinedClass <- paste("l", sumCoord-nrow(cutPoints)+1, sep = "")
if(is.null(result[[combinedClass]])){
result[[combinedClass]] = c()
}
result[combinedClass] <- c(result[combinedClass], data$Project)
}
}
return(result)
print(result)
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
cutPoints = cutpoints
#print(cutPoints)
data <- modelData
numVariables <- nrow(cutPoints)
numBins <- ncol(cutPoints) - 1
totalClassifications <- numVariables*numBins - numVariables + 1
levels <- paste("l", 1:totalClassifications, sep = "")
result <- list()
if(nrow(data) > 0){
for (i in 1:nrow(data)) {
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
combinedClass <- paste("l", sumCoord-nrow(cutPoints)+1, sep = "")
if(is.null(result[[combinedClass]])){
result[[combinedClass]] = c()
}
result[combinedClass] <- c(result[combinedClass], data$Project)
}
}
cutPoints = cutpoints
#print(cutPoints)
data <- modelData
numVariables <- nrow(cutPoints)
numBins <- ncol(cutPoints) - 1
totalClassifications <- numVariables*numBins - numVariables + 1
levels <- paste("l", 1:totalClassifications, sep = "")
result <- list()
if(nrow(data) > 0){
for (i in 1:nrow(data)) {
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
combinedClass <- paste("l", sumCoord-nrow(cutPoints)+1, sep = "")
if(is.null(result[[combinedClass]])){
result[[combinedClass]] = c()
}
result[combinedClass] <- c(result[combinedClass], data$Project)
}
}
print(result)
return(result)
classify <- function(data, cutPoints) {
cutPoints = cutpoints
#print(cutPoints)
data <- modelData
numVariables <- nrow(cutPoints)
numBins <- ncol(cutPoints) - 1
totalClassifications <- numVariables*numBins - numVariables + 1
levels <- paste("l", 1:totalClassifications, sep = "")
result <- list()
if(nrow(data) > 0){
for (i in 1:nrow(data)) {
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
combinedClass <- paste("l", sumCoord-nrow(cutPoints)+1, sep = "")
if(is.null(result[[combinedClass]])){
result[[combinedClass]] = c()
}
result[combinedClass] <- c(result[combinedClass], data$Project)
}
}
print(result)
return(result)
}
classify <- function(data, cutPoints) {
#cutPoints = cutpoints
#print(cutPoints)
#data <- modelData
numVariables <- nrow(cutPoints)
numBins <- ncol(cutPoints) - 1
totalClassifications <- numVariables*numBins - numVariables + 1
levels <- paste("l", 1:totalClassifications, sep = "")
result <- list()
if(nrow(data) > 0){
for (i in 1:nrow(data)) {
sumCoord <- 0
#classifications <- c()
for (p in rownames(cutPoints)) {
#print(p)
#p = "SLOC"
parameterResult <- cut(data[i, p], breaks = cutPoints[p, ], labels = FALSE)
#classifications <- c(classifications, parameterResult)
print(parameterResult)
sumCoord <- sumCoord + parameterResult
}
print(sumCoord)
combinedClass <- paste("l", sumCoord-nrow(cutPoints)+1, sep = "")
if(is.null(result[[combinedClass]])){
result[[combinedClass]] = c()
}
result[combinedClass] <- c(result[combinedClass], data$Project)
}
}
print(result)
return(result)
}
cutpoints = matrix(nrow = 3, ncol = length(sloc_cut_points))
rownames(cutpoints) = c("SLOC", "Duration", "Personnel")
cutpoints["SLOC",] = sloc_cut_points
cutpoints["Duration",] = duration_cut_points
cutpoints["Personnel",] = personnel_cut_points
print(cutpoints)
totalClassifications <- numVariables*numBins - numVariables + 1
classifiedDataPoints <- classify(modelData, cutpoints)
print(classifiedDataPoints)
data
knitr::opts_chunk$set(echo = TRUE)
source("utils/feature_selection.R")
source("utils/data_selection.R")
source("utils/model_funcs.R")
source("accuracy_confidence_evaluation.R")
source("transaction_based_model.R")
install.package("classInt")
install.packages("classInt")
# Using the "sig_bs" results, create a graph to represent the direct graph for the models.
library(igraph)
install.packages("igraph")
# Using the "sig_bs" results, create a graph to represent the direct graph for the models.
library(igraph)
for(metric_i in 1:length(accuracy_metrics)){
selectedData <- sig_bs[sig_bs$metric == metric_labels[metric_i],]
m <- matrix(0, nrow = length(models), ncol = length(models), byrow = FALSE)
colnames(m) <- names(models)
rownames(m) <- names(models)
for(i in 1:nrow(selectedData)){
if(selectedData$BH_p_value[i] < 0.05){
if(selectedData$direction[i] == "+"){
m[as.character(selectedData$model1[i]), as.character(selectedData$model2[i])] = 1
}else if(selectedData$direction[i] == "-"){
m[as.character(selectedData$model2[i]), as.character(selectedData$model1[i])] = 1
}
}
}
# if A -> B -> C, remove edge A -> C
for(i in 1:length(models)){
for(j in 1:length(models)){
if(m[i,j] == 1){
for(k in 1:length(models)){
if(m[j,k] == 1)
m[i,k] = 0
}
}
}
}
#plot the directed graph
net=graph.adjacency(m,mode="directed",weighted=TRUE,diag=FALSE)
plot.igraph(net,vertex.label=V(net)$name, layout=layout.fruchterman.reingold,
vertex.color="white", vertex.label.color="black", vertex.size=25,
edge.color="black",edge.width=3, edge.arrow.size=0.5, edge.arrow.width=1.2)
title(main = metric_labels[metric_i])
}
save.image("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/android_analysis_datasets/data-6-30-categorized-benchmark-data.RData")
save.image("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/android_analysis_datasets/data-6-30-categorized-benchmark-data-1.RData")
load("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/android_analysis_datasets/data-6-30-categorized-benchmark-data-1.RData")
print(categorizedDataset)
load("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/accuracy_analysis2/data-6-30-categorized-benchmark-data.RData")
View(categorizedDataset)
View(categorizedDataset)
save.image("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/android_analysis_datasets/data-6-30-categorized-benchmark-data-2.RData")
load("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/accuracy_analysis2/data-6-30-categorized-benchmark-data.RData")
load("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/accuracy_analysis2/data-4-28-complete-results-android-1.RData")
# Using the "sig_bs" results, create a graph to represent the direct graph for the models.
library(igraph)
for(metric_i in 1:length(accuracy_metrics)){
selectedData <- sig_bs[sig_bs$metric == metric_labels[metric_i],]
m <- matrix(0, nrow = length(models), ncol = length(models), byrow = FALSE)
colnames(m) <- names(models)
rownames(m) <- names(models)
for(i in 1:nrow(selectedData)){
if(selectedData$BH_p_value[i] < 0.05){
if(selectedData$direction[i] == "+"){
m[as.character(selectedData$model1[i]), as.character(selectedData$model2[i])] = 1
}else if(selectedData$direction[i] == "-"){
m[as.character(selectedData$model2[i]), as.character(selectedData$model1[i])] = 1
}
}
}
# if A -> B -> C, remove edge A -> C
for(i in 1:length(models)){
for(j in 1:length(models)){
if(m[i,j] == 1){
for(k in 1:length(models)){
if(m[j,k] == 1)
m[i,k] = 0
}
}
}
}
#plot the directed graph
net=graph.adjacency(m,mode="directed",weighted=TRUE,diag=FALSE)
plot.igraph(net,vertex.label=V(net)$name, layout=layout.fruchterman.reingold,
vertex.color="white", vertex.label.color="black", vertex.size=25,
edge.color="black",edge.width=3, edge.arrow.size=0.5, edge.arrow.width=1.2)
title(main = metric_labels[metric_i])
}
# family-wise hypothesis test
source('familywiseHypoTest2.R')
foldResults <- cvResults$foldResults
# sig_cv <- familywiseHypoTest(iterationResults=foldResults, accuracy_metrics, model_names)
# head(sig_cv)
sig_bs <- familywiseHypoTest(iterationResults=iterResults, accuracy_metrics, model_names, "boot")
View(benchmarkResults)
View(benchmarkResults)
load("//desktop-ntk8gip/d/ResearchSpace/ResearchProjects/UMLx/data/GitAndroidAnalysis/accuracy_analysis2/data-4-27-complete-results.RData")
View(benchmarkResults)
View(benchmarkResults)
#bootstrappingSE(SWTIIIModelData, otherSizeMetricsData, model3, 10000, 0.83)
bsEstimations <- bsRet[['bsEstimations']]
iterResults <- bsRet[['iterResults']]
View(iterResults)
View(iterResults)
model_labels <- c()
for(i in 1:length(models)){
for(j in 1:length(accuracy_metrics)){
model_labels = c(model_labels, names(models)[i])
}
}
metric_labels <- c()
for(i in 1:length(models)){
for(j in 1:length(accuracy_metrics)){
metric_labels = c(metric_labels, accuracy_metrics[j])
}
}
df <- data.frame(t(bsEstimations))
df$labels <- rownames(df)
df$model_labels <- model_labels
df$metric_labels <- metric_labels
print(metric_labels)
for (i in 1:length(accuracy_metrics)){
g = metric_labels[i]
g_label <- toupper(g)
selectedData <- df[df$metric_labels == g,]
p <- ggplot(selectedData, aes(x = labels, y = mean)) +
geom_errorbar(aes(ymin=lower, ymax=upper), colour="black", width=.1) +
geom_point(size=2, shape=21, fill="black") + # 21 is filled circle
xlab('MODEL') +
ylab(g_label) +
scale_x_discrete(breaks=selectedData$label, labels=as.vector(selectedData$model_labels)) +
ggtitle(paste(g_label, "- 84% Confidence Intervals", setp=""))
print(p)
}
cvAccuracyResults <- data.frame(cvResults$accuracyResults)
cvAccuracyResults$model_labels <- model_labels
cvAccuracyResults$metric_labels <- metric_labels
cvRankResults <- data.frame(names(models))
names(cvRankResults)<-c("model_labels")
for (i in 1:length(accuracy_metrics)){
g = metric_labels[i]
selectedData <- cvAccuracyResults[cvAccuracyResults$metric_labels == g,]
selectedData <- selectedData[,-3]#delete the metric_labels
names(selectedData)<-c(g, "model_labels")
if(g == "mmre" || g == "mdmre" || g == "mae"){
selectedData[paste("rank", i, sep = "")] <- rank(selectedData[,1], ties.method = "min")
}else{
selectedData[paste("rank", i, sep = "")] <- rank(-selectedData[,1], ties.method = "min")
}
cvRankResults <- merge(cvRankResults, selectedData, by = "model_labels", all=FALSE)
}
#make a total rank(rank*) base on the ranki
rank_sum <- vector(mode = "integer",length = length(models))
for (i in 1:length(models)){
selectedData <- cvRankResults[i,]
for(j in 1:length(accuracy_metrics)){
rank_sum[i] <- rank_sum[i] + selectedData[,2*j+1]
}
}
rank_sum <- rank(rank_sum, ties.method = "min")
cvRankResults["rank*"] <- rank_sum
cvRankResults <- cvRankResults[order(cvRankResults$'rank*'),]
#change the first line as the row name
rownames(cvRankResults) = cvRankResults[,1]
cvRankResults <- cvRankResults[,-1]
print(round(cvRankResults,2))
# family-wise hypothesis test
source('familywiseHypoTest2.R')
foldResults <- cvResults$foldResults
# sig_cv <- familywiseHypoTest(iterationResults=foldResults, accuracy_metrics, model_names)
# head(sig_cv)
sig_bs <- familywiseHypoTest(iterationResults=iterResults, accuracy_metrics, model_names, "boot")
round_df <- function(df, digits) {
nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
df[,nums] <- round(df[,nums], digits = digits)
(df)
}
sig_bs_f = sig_bs[which(sig_bs$BH_p_value < 0.05),]
sig_bs_f = sig_bs_f[which(sig_bs_f$metric %in% c("mmre", "mdmre", "pred25", "mae")),]
sig_bs_f = sig_bs_f[which(sig_bs_f$model1 %in% c("tm3") | sig_bs_f$model2 %in% c("tm3")),]
sig_bs_f = sig_bs_f[order(sig_bs_f$bonferroni_p_value),]
sig_bs_f = round_df(sig_bs_f, 2)
print(sig_bs_f)
# Using the "sig_bs" results, create a graph to represent the direct graph for the models.
library(igraph)
for(metric_i in 1:length(accuracy_metrics)){
selectedData <- sig_bs[sig_bs$metric == metric_labels[metric_i],]
m <- matrix(0, nrow = length(models), ncol = length(models), byrow = FALSE)
colnames(m) <- names(models)
rownames(m) <- names(models)
for(i in 1:nrow(selectedData)){
if(selectedData$BH_p_value[i] < 0.05){
if(selectedData$direction[i] == "+"){
m[as.character(selectedData$model1[i]), as.character(selectedData$model2[i])] = 1
}else if(selectedData$direction[i] == "-"){
m[as.character(selectedData$model2[i]), as.character(selectedData$model1[i])] = 1
}
}
}
# if A -> B -> C, remove edge A -> C
for(i in 1:length(models)){
for(j in 1:length(models)){
if(m[i,j] == 1){
for(k in 1:length(models)){
if(m[j,k] == 1)
m[i,k] = 0
}
}
}
}
#plot the directed graph
net=graph.adjacency(m,mode="directed",weighted=TRUE,diag=FALSE)
plot.igraph(net,vertex.label=V(net)$name, layout=layout.fruchterman.reingold,
vertex.color="white", vertex.label.color="black", vertex.size=25,
edge.color="black",edge.width=3, edge.arrow.size=0.5, edge.arrow.width=1.2)
title(main = metric_labels[metric_i])
}
